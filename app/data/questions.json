[
  {
    "module": "Spring",
    "question": "Spring框架的核心特性不包括以下哪项？（ ） ）",
    "type": "choice",
    "answer": "D",
    "options": [
      "A. 控制反转（IoC）",
      "B. 面向切面编程（AOP）",
      "C. 自动事务管理",
      "D. 底层数据库连接池实现"
    ],
    "explanation": "答案解析：Spring核心是IoC和AOP，事务管理是其重要功能，但数据库连接池通常依赖第三方（如HikariCP），非Spring底层实现。"
  },
  {
    "module": "Spring",
    "question": "以下哪种不是Spring依赖注入（ ）I）的实现方式？（ ） ）",
    "type": "choice",
    "answer": "C",
    "options": [
      "A. 构造函数注入",
      "B. setter方法注入",
      "C. 接口注入",
      "D. 注解注入（@Autowired）"
    ],
    "explanation": "答案解析：接口注入是早期DI方式，Spring虽支持但不推荐，主流为构造函数、setter和注解注入。"
  },
  {
    "module": "Spring",
    "question": "Spring中，Bean的默认作用域是（ ） ）",
    "type": "judge",
    "answer": "F",
    "options": [
      "正确",
      "错误"
    ],
    "explanation": "答案解析：默认作用域为singleton（单例），容器中仅存在一个实例；prototype为原型，每次获取创建新实例。"
  },
  {
    "module": "Spring",
    "question": "`@Autowired`注解默认的注入方式是（ ） ）",
    "type": "choice",
    "answer": "B",
    "options": [
      "A. 按名称注入",
      "B. 按类型注入",
      "C. 按构造函数注入",
      "D. 按接口注入"
    ],
    "explanation": "答案解析：`@Autowired`默认按类型匹配，若存在多个同类型Bean，需配合`@Qualifier`按名称注入。"
  },
  {
    "module": "Spring",
    "question": "Spring的`ApplicationContext`相比`BeanFactory`的优势不包括（ ） ）",
    "type": "choice",
    "answer": "C",
    "options": [
      "A. 支持国际化",
      "B. 支持事件发布",
      "C. 延迟加载Bean",
      "D. 预加载单例Bean"
    ],
    "explanation": "答案解析：BeanFactory是延迟加载（getBean时创建），ApplicationContext是预加载单例Bean，C是BeanFactory的特点。"
  },
  {
    "module": "Spring",
    "question": "以下哪个注解用于指定Bean的初始化方法？（ ） ）",
    "type": "choice",
    "answer": "D",
    "options": [
      "A. `@PostConstruct`",
      "B. `@PreDestroy`",
      "C. `@InitMethod`",
      "D. `@Bean(initMethod=\"xxx\")`"
    ],
    "explanation": "答案解析：`@Bean`的`initMethod`属性指定初始化方法；`@PostConstruct`是JSR注解，作用类似但属于Java规范。"
  },
  {
    "module": "Spring",
    "question": "以下哪个接口用于监听Spring容器的事件？（ ） ）",
    "type": "choice",
    "answer": "B",
    "options": [
      "A. `ApplicationEvent`",
      "B. `ApplicationListener`",
      "C. `ApplicationEventPublisher`",
      "D. `EventPublisher`"
    ],
    "explanation": "答案解析：`ApplicationListener`用于监听事件，`ApplicationEventPublisher`用于发布事件，`ApplicationEvent`是事件基类。"
  },
  {
    "module": "Spring",
    "question": "Spring的`@Profile`注解的作用是（ ） ）",
    "type": "choice",
    "answer": "B",
    "options": [
      "A. 指定Bean的作用域",
      "B. 根据环境激活不同的Bean",
      "C. 标记Bean为主要Bean",
      "D. 延迟Bean的初始化"
    ],
    "explanation": "答案解析：`@Profile`用于区分环境（如dev、test、prod），仅激活匹配的Bean。"
  },
  {
    "module": "Spring",
    "question": "以下哪个不是Spring的AOP通知类型？（ ） ）",
    "type": "choice",
    "answer": "D",
    "options": [
      "A. 前置通知（Before）",
      "B. 后置通知（After）",
      "C. 异常通知（Throws）",
      "D. 循环通知（Loop）"
    ],
    "explanation": "答案解析：AOP通知类型包括前置、后置、返回、异常、环绕通知，无循环通知。"
  },
  {
    "module": "Spring",
    "question": "Spring中，`@Primary`注解的作用是（ ） ）",
    "type": "choice",
    "answer": "B",
    "options": [
      "A. 标记Bean为必须存在",
      "B. 解决同类型Bean注入的歧义，指定首选Bean",
      "C. 延迟Bean的初始化",
      "D. 定义Bean的名称"
    ],
    "explanation": "答案解析：当存在多个同类型Bean时，`@Primary`指定的Bean会被优先注入。"
  },
  {
    "module": "Spring",
    "question": "`ClassPathXmlApplicationContext`的作用是（ ） ）",
    "type": "choice",
    "answer": "B",
    "options": [
      "A. 从文件系统加载XML配置",
      "B. 从类路径加载XML配置",
      "C. 从网络加载XML配置",
      "D. 加载注解配置"
    ],
    "explanation": "答案解析：`ClassPathXmlApplicationContext`用于加载类路径下的XML配置文件，`FileSystemXmlApplicationContext`加载文件系统路径。"
  },
  {
    "module": "Spring",
    "question": "以下哪个注解用于将类标识为Spring的组件？（ ） ）",
    "type": "choice",
    "answer": "A",
    "options": [
      "A. `@Component`",
      "B. `@Bean`",
      "C. `@Configuration`",
      "D. `@Service`"
    ],
    "explanation": "答案解析：`@Component`是通用组件注解，`@Service`、`@Controller`、`@Repository`是其特殊化（分别用于服务、控制器、持久层）。"
  },
  {
    "module": "Spring",
    "question": "Spring的`FactoryBean`与普通Bean的区别是（ ） ）",
    "type": "choice",
    "answer": "A",
    "options": [
      "A. `FactoryBean`是工厂，用于创建其他Bean",
      "B. `FactoryBean`只能通过XML配置",
      "C. 普通Bean不能依赖`FactoryBean`",
      "D. `FactoryBean`的生命周期与普通Bean不同"
    ],
    "explanation": "答案解析：`FactoryBean`是特殊Bean，用于创建复杂Bean（如`SqlSessionFactoryBean`），通过`getObject()`方法返回实际Bean。"
  },
  {
    "module": "Spring",
    "question": "Spring的`Resource`接口不支持访问哪种资源？（ ） ）",
    "type": "choice",
    "answer": "D",
    "options": [
      "A. 类路径资源（classpath:）",
      "B. 文件系统资源（file:）",
      "C. 网络资源（http:）",
      "D. 数据库资源（jdbc:）"
    ],
    "explanation": "答案解析：`Resource`支持类路径、文件、网络等资源，数据库资源通过数据源访问，不属此类。"
  },
  {
    "module": "Spring",
    "question": "以下哪个不是Spring的Bean作用域？（ ） ）",
    "type": "choice",
    "answer": "C",
    "options": [
      "A. globalSession",
      "B. application",
      "C. thread",
      "D. request"
    ],
    "explanation": "答案解析：Spring的标准作用域包括singleton、prototype、request、session、globalSession、application，无thread。"
  },
  {
    "module": "Spring",
    "question": "`@Qualifier`注解通常与哪个注解配合使用？（ ） ）",
    "type": "choice",
    "answer": "B",
    "options": [
      "A. `@Bean`",
      "B. `@Autowired`",
      "C. `@Component`",
      "D. `@Scope`"
    ],
    "explanation": "答案解析：`@Autowired`按类型注入，若存在多个同类型Bean，`@Qualifier`指定Bean名称解决歧义。"
  },
  {
    "module": "Spring",
    "question": "关于`BeanFactory`和`ApplicationContext`的关系，正确的是（ ） ）",
    "type": "choice",
    "answer": "A",
    "options": [
      "A. `ApplicationContext`是`BeanFactory`的子接口",
      "B. `BeanFactory`是`ApplicationContext`的子接口",
      "C. 两者无继承关系",
      "D. 两者是同一接口的不同实现"
    ],
    "explanation": "答案解析：`ApplicationContext`继承`BeanFactory`，扩展了企业级功能（如事件、国际化）。"
  },
  {
    "module": "Spring",
    "question": "Spring中，`@PostConstruct`注解标注的方法执行时机是（ ） ）",
    "type": "choice",
    "answer": "B",
    "options": [
      "A. Bean实例化后，属性填充前",
      "B. Bean属性填充后，初始化方法前",
      "C. Bean初始化方法后",
      "D. Bean销毁前"
    ],
    "explanation": "答案解析：`@PostConstruct`在Bean属性填充完成后、初始化方法（如`afterPropertiesSet`）执行前调用。"
  },
  {
    "module": "Spring",
    "question": "`@Configuration`注解标注的类中，`@Bean`方法的特点是（ ） ）",
    "type": "choice",
    "answer": "B",
    "options": [
      "A. 每次调用都会创建新的Bean实例",
      "B. 会被Spring代理，确保单例性",
      "C. 只能返回自定义类的实例",
      "D. 必须指定Bean的名称"
    ],
    "explanation": "答案解析：`@Configuration`类中的`@Bean`方法会被代理，多次调用返回同一实例（单例），无需手动控制。"
  },
  {
    "module": "Spring",
    "question": "以下哪个接口用于获取Bean在容器中的名称？（ ） ）",
    "type": "choice",
    "answer": "A",
    "options": [
      "A. `BeanNameAware`",
      "B. `BeanFactoryAware`",
      "C. `ApplicationContextAware`",
      "D. `InitializingBean`"
    ],
    "explanation": "答案解析：`BeanNameAware`的`setBeanName`方法可获取Bean的名称；`BeanFactoryAware`获取BeanFactory。"
  },
  {
    "module": "Spring",
    "question": "Spring的事务传播行为中，`REQUIRES_NEW`表示（ ） ）",
    "type": "choice",
    "answer": "C",
    "options": [
      "A. 如果当前存在事务，加入该事务；否则创建新事务",
      "B. 无论当前是否存在事务，都创建新事务",
      "C. 如果当前存在事务，挂起该事务，创建新事务",
      "D. 依赖当前事务，若不存在则抛出异常"
    ],
    "explanation": "答案解析：`REQUIRES_NEW`会创建新事务，若当前有事务则挂起；`REQUIRED`是加入现有事务。"
  },
  {
    "module": "Spring",
    "question": "关于Spring的`@Value`注解，以下说法错误的是（ ） ）",
    "type": "choice",
    "answer": "C",
    "options": [
      "A. 可用于注入配置文件中的属性值",
      "B. 可注入SpEL表达式计算结果",
      "C. 只能用于字段注入，不能用于方法参数",
      "D. 可设置默认值（如`@Value( ${app.name:default} )`）"
    ],
    "explanation": "答案解析：`@Value`可用于字段、方法参数、构造函数参数注入。"
  },
  {
    "module": "Spring",
    "question": "以下哪个注解用于禁用Spring的自动装配？（ ） ）",
    "type": "choice",
    "answer": "C",
    "options": [
      "A. `@NoAutoWire`",
      "B. `@DisableAutowire`",
      "C. `@Autowired(required=false)`",
      "D. `@Autowired`无法禁用，需通过XML配置"
    ],
    "explanation": "答案解析：`@Autowired(required=false)`表示注入非必需，若不存在则不注入，间接实现“可选”；无`@NoAutoWire`等注解。"
  },
  {
    "module": "Spring",
    "question": "Spring的`@Service`注解的作用是（ ） ）",
    "type": "choice",
    "answer": "B",
    "options": [
      "A. 标记类为控制器组件",
      "B. 标记类为服务层组件",
      "C. 标记类为配置类",
      "D. 标记类为持久层组件"
    ],
    "explanation": "答案解析：`@Service`用于服务层，`@Controller`用于控制器，`@Repository`用于持久层，均为`@Component`的特例。"
  },
  {
    "module": "Spring",
    "question": "Spring中，原型（prototype）作用域的Bean的生命周期特点是（ ） ）",
    "type": "choice",
    "answer": "B",
    "options": [
      "A. 容器启动时创建，关闭时销毁",
      "B. 每次获取时创建，容器不管理销毁",
      "C. 每次请求时创建，请求结束时销毁",
      "D. 全局唯一，容器全程管理"
    ],
    "explanation": "答案解析：原型Bean在`getBean`时创建，容器不负责销毁，需手动管理。"
  },
  {
    "module": "Spring",
    "question": "Spring的`Bean`生命周期中，哪个阶段在属性填充之后、初始化方法之前执行？（ ） ）",
    "type": "choice",
    "answer": "C",
    "options": [
      "A. 实例化（Instantiation）",
      "B. 销毁（Destruction）",
      "C. `@PostConstruct`方法调用",
      "D. 初始化（Initialization）"
    ],
    "explanation": "答案解析：Bean生命周期关键阶段：实例化→属性填充→`@PostConstruct`→初始化方法（如`afterPropertiesSet`）→使用→销毁。"
  },
  {
    "module": "Spring",
    "question": "Spring的`@Transactional`注解默认的事务传播行为是（ ） ）",
    "type": "choice",
    "answer": "A",
    "options": [
      "A. `REQUIRED`",
      "B. `REQUIRES_NEW`",
      "C. `SUPPORTS`",
      "D. `MANDATORY`"
    ],
    "explanation": "答案解析：`REQUIRED`表示：如果当前存在事务，加入该事务；否则创建新事务，是默认传播行为。"
  },
  {
    "module": "Spring",
    "question": "关于Spring的`singleton`作用域Bean，以下说法错误的是（ ） ）",
    "type": "choice",
    "answer": "D",
    "options": [
      "A. 容器中仅存在一个实例",
      "B. 线程不安全，需自行处理并发问题",
      "C. 初始化后一直存在，直到容器销毁",
      "D. 每次`getBean`都会创建新实例"
    ],
    "explanation": "答案解析：`singleton`是单例，首次加载后复用同一实例；`prototype`才会每次创建新实例。"
  },
  {
    "module": "Spring",
    "question": "Spring的`@Qualifier`注解的`value`属性作用是（ ） ）",
    "type": "choice",
    "answer": "B",
    "options": [
      "A. 指定Bean的类型",
      "B. 指定Bean的名称",
      "C. 指定Bean的作用域",
      "D. 指定Bean的优先级"
    ],
    "explanation": "答案解析：`@Qualifier(\"userService\")`配合`@Autowired`，指定注入名称为`userService`的Bean。"
  },
  {
    "module": "Spring",
    "question": "以下哪个不是Spring事务管理的方式？（ ） ）",
    "type": "choice",
    "answer": "D",
    "options": [
      "A. 编程式事务（`TransactionTemplate`）",
      "B. 声明式事务（`@Transactional`）",
      "C. XML配置事务",
      "D. 自动事务（无需任何配置）"
    ],
    "explanation": "答案解析：Spring事务需显式配置（编程式或声明式），无“自动事务”模式。"
  },
  {
    "module": "Spring",
    "question": "Spring的`BeanFactory`加载Bean的方式是（ ） ）",
    "type": "choice",
    "answer": "B",
    "options": [
      "A. 预加载（启动时创建所有单例Bean）",
      "B. 延迟加载（首次`getBean`时创建）",
      "C. 按需加载（根据配置决定）",
      "D. 并行加载（多线程创建）"
    ],
    "explanation": "答案解析：`BeanFactory`是延迟加载，`ApplicationContext`是预加载单例Bean。"
  },
  {
    "module": "Spring",
    "question": "Spring AOP中，“织入”（Weaving）是指（ ） ）",
    "type": "choice",
    "answer": "B",
    "options": [
      "A. 定义切面的过程",
      "B. 将切面代码插入到目标对象的过程",
      "C. 选择切入点的过程",
      "D. 执行通知的过程"
    ],
    "explanation": "答案解析：织入是AOP的核心步骤，将切面逻辑与目标方法结合，Spring AOP采用运行时织入。"
  },
  {
    "module": "Spring",
    "question": "以下哪个注解用于标记Bean为多例（原型）作用域？（ ） ）",
    "type": "choice",
    "answer": "A",
    "options": [
      "A. `@Scope(\"prototype\")`",
      "B. `@Prototype`",
      "C. `@Scope(\"multiple\")`",
      "D. `@Multiple`"
    ],
    "explanation": "答案解析：`@Scope`注解指定作用域，`prototype`表示原型（多例），`singleton`表示单例（默认）。"
  },
  {
    "module": "Spring",
    "question": "关于Spring的`@Component`和`@Bean`的区别，以下说法错误的是（ ） ）",
    "type": "choice",
    "answer": "D",
    "options": [
      "A. `@Component`用于类，`@Bean`用于方法",
      "B. `@Component`通过类路径扫描注册，`@Bean`通过配置类方法注册",
      "C. `@Bean`可注册第三方类的Bean，`@Component`只能标注自定义类",
      "D. 两者功能完全相同，可互换使用"
    ],
    "explanation": "答案解析：`@Component`适用于自定义类，`@Bean`适用于第三方类（如`DataSource`），使用场景不同。"
  },
  {
    "module": "Spring",
    "question": "以下哪个不是Spring的`Bean`作用域的应用场景？（ ） ）",
    "type": "choice",
    "answer": "D",
    "options": [
      "A. `singleton`：无状态的工具类（如`StringUtils`）",
      "B. `prototype`：有状态的对象（如`User`实例）",
      "C. `request`：存储请求级数据（如`ServletRequest`属性）",
      "D. `session`：全局缓存（如系统配置）"
    ],
    "explanation": "答案解析：`session`作用域的Bean与用户会话绑定，不适合全局缓存；全局缓存用`singleton`。"
  },
  {
    "module": "Spring",
    "question": "Spring的`@Transactional`注解的`rollbackFor`属性作用是（ ） ）",
    "type": "choice",
    "answer": "A",
    "options": [
      "A. 指定哪些异常触发事务回滚",
      "B. 指定哪些异常不触发事务回滚",
      "C. 指定事务的隔离级别",
      "D. 指定事务的传播行为"
    ],
    "explanation": "答案解析：`rollbackFor =\n              Exception.class`表示所有异常都回滚；默认仅对`RuntimeException`和`Error`回滚。"
  },
  {
    "module": "Spring",
    "question": "在Spring中，Bean的默认作用域是prototype。（ ） ）",
    "type": "judge",
    "answer": "F",
    "options": [
      "正确",
      "错误"
    ],
    "explanation": "答案解析：默认作用域是singleton"
  },
  {
    "module": "Spring",
    "question": "Spring的IoC容器负责创建Bean实例，并管理Bean的生命周期。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  },
  {
    "module": "Spring",
    "question": "BeanFactory是Spring IoC容器的顶层接口，ApplicationContext是其实现类之一。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  },
  {
    "module": "Spring",
    "question": "在Spring中，使用@Autowired注解注入依赖时，默认按照名称匹配。（ ） ）",
    "type": "judge",
    "answer": "F",
    "options": [
      "正确",
      "错误"
    ],
    "explanation": "答案解析：默认按照类型匹配"
  },
  {
    "module": "Spring",
    "question": "Spring支持基于XML和注解两种方式配置Bean。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  },
  {
    "module": "Spring",
    "question": "Spring的事务管理只能通过编程式事务实现。（ ） ）",
    "type": "judge",
    "answer": "F",
    "options": [
      "正确",
      "错误"
    ],
    "explanation": "答案解析：还可通过声明式事务实现且声明式事务更常用"
  },
  {
    "module": "Spring",
    "question": "BeanFactory 作为 Spring IoC 容器的基础接口，其特点是启动时预加载所有单例 Bean。（ ） ）",
    "type": "judge",
    "answer": "F",
    "options": [
      "正确",
      "错误"
    ],
    "explanation": "答案解析：BeanFactory 是延迟加载仅在调用 `getBean` 时创建\n              Bean；ApplicationContext 才会预加载单例 Bean"
  },
  {
    "module": "Spring",
    "question": "ApplicationContext 继承自 BeanFactory，并扩展了国际化、资源访问等企业级功能。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  },
  {
    "module": "Spring",
    "question": "Spring 中，`@PostConstruct` 注解标注的方法会在 Bean 属性填充完成后、初始化方法执行前被调用。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  },
  {
    "module": "Spring",
    "question": "使用 `@Qualifier` 注解可以解决 `@Autowired` 注解因类型匹配多个 Bean 而产生的歧义问题。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  },
  {
    "module": "Spring",
    "question": "构造器注入相比 setter 注入，能更好地保证 Bean 的不可变性，且可避免循环依赖问题。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  },
  {
    "module": "Spring",
    "question": "Spring 中，`@Scope(\"singleton\")` 标注的 Bean 在整个容器中只会存在一个实例。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  },
  {
    "module": "Spring",
    "question": "Spring 的 `@Configuration` 注解标注的类，其内部被 `@Bean` 注解标注的方法会被代理，以确保 Bean 的单例性。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  },
  {
    "module": "Spring",
    "question": "`ClassPathXmlApplicationContext` 是 ApplicationContext 的实现类，用于从类路径加载 XML 配置文件。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  },
  {
    "module": "Spring",
    "question": "Spring 中，依赖注入的本质是容器在创建 Bean 时，自动将其依赖的其他 Bean 注入到其中。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  },
  {
    "module": "SpringMVC",
    "question": "Spring MVC的核心前端控制器是（ ） ）",
    "type": "judge",
    "answer": "F",
    "options": [
      "正确",
      "错误"
    ],
    "explanation": "答案解析：`DispatcherServlet`是Spring\n              MVC的核心，负责接收请求、分发到Controller、处理响应。"
  },
  {
    "module": "SpringMVC",
    "question": "`@RequestMapping`注解的`value`属性的作用是（ ） ）",
    "type": "choice",
    "answer": "B",
    "options": [
      "A. 指定请求方法（GET/POST等）",
      "B. 指定请求路径",
      "C. 指定响应类型",
      "D. 指定参数名称"
    ],
    "explanation": "答案解析：`value`属性定义请求路径，可简写为`@RequestMapping(\"/path\")`；`method`属性指定请求方法。"
  },
  {
    "module": "SpringMVC",
    "question": "以下哪个注解用于获取URL路径中的参数（如`/user/{id}`中的id）？（ ） ）",
    "type": "choice",
    "answer": "B",
    "options": [
      "A. `@RequestParam`",
      "B. `@PathVariable`",
      "C. `@RequestHeader`",
      "D. `@CookieValue`"
    ],
    "explanation": "答案解析：`@PathVariable`获取路径参数；`@RequestParam`获取请求参数（如`?id=1`）。"
  },
  {
    "module": "SpringMVC",
    "question": "Spring MVC中，`ModelAndView`的作用是（ ） ）",
    "type": "choice",
    "answer": "C",
    "options": [
      "A. 仅封装视图名称",
      "B. 仅封装模型数据",
      "C. 封装视图名称和模型数据",
      "D. 处理请求参数"
    ],
    "explanation": "答案解析：`ModelAndView`包含`viewName`（视图名）和`model`（模型数据），用于Controller向视图传递数据。"
  },
  {
    "module": "SpringMVC",
    "question": "视图解析器（`ViewResolver`）的主要作用是（ ） ）",
    "type": "choice",
    "answer": "A",
    "options": [
      "A. 将逻辑视图名解析为物理视图路径",
      "B. 处理请求参数",
      "C. 执行Controller方法",
      "D. 渲染视图"
    ],
    "explanation": "答案解析：视图解析器根据逻辑视图名（如“index”）结合前缀（如“/WEB-INF/views/”）和后缀（如“.jsp”）生成物理路径。"
  },
  {
    "module": "SpringMVC",
    "question": "`@ResponseBody`注解的作用是（ ） ）",
    "type": "choice",
    "answer": "B",
    "options": [
      "A. 将方法返回值作为模型数据",
      "B. 将方法返回值直接写入响应体（如JSON）",
      "C. 重定向到指定URL",
      "D. 转发到指定视图"
    ],
    "explanation": "答案解析：`@ResponseBody`使返回值不经过视图解析，直接作为响应体（如返回JSON时常用）。"
  },
  {
    "module": "SpringMVC",
    "question": "Spring MVC的拦截器（`Interceptor`）需要实现哪个接口？（ ） ）",
    "type": "choice",
    "answer": "B",
    "options": [
      "A. `Filter`",
      "B. `HandlerInterceptor`",
      "C. `Interceptor`",
      "D. `WebMvcInterceptor`"
    ],
    "explanation": "答案解析：拦截器需实现`HandlerInterceptor`，重写`preHandle`、`postHandle`、`afterCompletion`方法。"
  },
  {
    "module": "SpringMVC",
    "question": "以下哪个方法在Controller方法执行后、视图渲染前调用？（ ） ）",
    "type": "choice",
    "answer": "B",
    "options": [
      "A. `preHandle`",
      "B. `postHandle`",
      "C. `afterCompletion`",
      "D. `doFilter`"
    ],
    "explanation": "答案解析：`preHandle`在Controller前执行，`postHandle`在Controller后、视图前执行，`afterCompletion`在视图后执行。"
  },
  {
    "module": "SpringMVC",
    "question": "`@RestController`注解是以下哪两个注解的组合？（ ） ）",
    "type": "choice",
    "answer": "A",
    "options": [
      "A. `@Controller`和`@ResponseBody`",
      "B. `@Controller`和`@ResponseStatus`",
      "C. `@Service`和`@ResponseBody`",
      "D. `@Component`和`@ResponseBody`"
    ],
    "explanation": "答案解析：`@RestController` = `@Controller` +\n              `@ResponseBody`，适用于RESTful接口，返回值直接作为响应体。"
  },
  {
    "module": "SpringMVC",
    "question": "Spring MVC中，处理文件上传的接口是（ ） ）",
    "type": "choice",
    "answer": "B",
    "options": [
      "A. `File`",
      "B. `MultipartFile`",
      "C. `UploadedFile`",
      "D. `HttpFile`"
    ],
    "explanation": "答案解析：`MultipartFile`用于接收上传的文件，提供`getOriginalFilename()`、`transferTo()`等方法。"
  },
  {
    "module": "SpringMVC",
    "question": "`@ExceptionHandler`注解的作用是（ ） ）",
    "type": "choice",
    "answer": "B",
    "options": [
      "A. 定义全局异常处理",
      "B. 定义当前Controller的异常处理",
      "C. 抛出异常",
      "D. 标记异常类"
    ],
    "explanation": "答案解析：`@ExceptionHandler`在Controller内部定义异常处理方法，配合`@ControllerAdvice`可实现全局处理。"
  },
  {
    "module": "SpringMVC",
    "question": "以下哪个注解用于将请求参数绑定到模型对象？（ ） ）",
    "type": "choice",
    "answer": "A",
    "options": [
      "A. `@ModelAttribute`",
      "B. `@RequestParam`",
      "C. `@PathVariable`",
      "D. `@Bind`"
    ],
    "explanation": "答案解析：`@ModelAttribute`将请求参数绑定到对象，并自动添加到模型中，如`public String\n              save(@ModelAttribute User user)`。"
  },
  {
    "module": "SpringMVC",
    "question": "Spring MVC中，静态资源（如CSS、JS）的默认处理方式是（ ） ）",
    "type": "choice",
    "answer": "A",
    "options": [
      "A. 被`DispatcherServlet`拦截，需手动配置排除",
      "B. 不被拦截，可直接访问",
      "C. 必须通过`@RequestMapping`映射",
      "D. 默认禁止访问"
    ],
    "explanation": "答案解析：默认`DispatcherServlet`映射`/`，会拦截静态资源，需通过`mvc:resources`或`WebMvcConfigurer`配置排除。"
  },
  {
    "module": "SpringMVC",
    "question": "`@RequestHeader`注解用于获取（ ） ）",
    "type": "choice",
    "answer": "C",
    "options": [
      "A. 请求参数",
      "B. URL路径参数",
      "C. HTTP请求头信息",
      "D. Cookie信息"
    ],
    "explanation": "答案解析：`@RequestHeader`获取请求头（如`@RequestHeader(\"User-Agent\") String\n              userAgent`）。"
  },
  {
    "module": "SpringMVC",
    "question": "`@CookieValue`注解用于获取（ ） ）",
    "type": "choice",
    "answer": "C",
    "options": [
      "A. 请求参数",
      "B. 请求头",
      "C. Cookie的值",
      "D. Session属性"
    ],
    "explanation": "答案解析：`@CookieValue(\"JSESSIONID\") String\n              sessionId`用于获取指定Cookie的值。"
  },
  {
    "module": "SpringMVC",
    "question": "以下哪个不是Spring MVC的视图类型？（ ） ）",
    "type": "choice",
    "answer": "D",
    "options": [
      "A. JSP视图（`InternalResourceView`）",
      "B. JSON视图（`MappingJackson2JsonView`）",
      "C. Redirect视图（`RedirectView`）",
      "D. 数据库视图"
    ],
    "explanation": "答案解析：数据库视图是数据库层面的概念，非Spring MVC视图。"
  },
  {
    "module": "SpringMVC",
    "question": "`@SessionAttributes`注解的作用是（ ） ）",
    "type": "choice",
    "answer": "A",
    "options": [
      "A. 将模型属性存储到Session中",
      "B. 获取Session中的属性",
      "C. 清除Session中的属性",
      "D. 禁用Session"
    ],
    "explanation": "答案解析：`@SessionAttributes(\"user\")`将模型中名为“user”的属性存入Session，实现跨请求共享。"
  },
  {
    "module": "SpringMVC",
    "question": "Spring MVC中，Controller方法的返回值类型不包括（ ） ）",
    "type": "choice",
    "answer": "D",
    "options": [
      "A. `String`（视图名）",
      "B. `void`（响应体或默认视图）",
      "C. `ModelAndView`",
      "D. `HttpServletRequest`"
    ],
    "explanation": "答案解析：`HttpServletRequest`是方法参数类型，用于接收请求对象，不能作为返回值。"
  },
  {
    "module": "SpringMVC",
    "question": "视图解析器的`order`属性的作用是（ ） ）",
    "type": "choice",
    "answer": "B",
    "options": [
      "A. 指定视图的优先级",
      "B. 指定解析器的执行顺序（值越小越先执行）",
      "C. 指定视图的缓存时间",
      "D. 指定视图的类型"
    ],
    "explanation": "答案解析：`order`值越小，视图解析器优先级越高，先尝试解析视图。"
  },
  {
    "module": "SpringMVC",
    "question": "`@ResponseStatus`注解的作用是（ ） ）",
    "type": "choice",
    "answer": "B",
    "options": [
      "A. 指定响应的视图名",
      "B. 指定响应的HTTP状态码",
      "C. 指定响应的Content-Type",
      "D. 重定向到指定URL"
    ],
    "explanation": "答案解析：`@ResponseStatus(code = 404)`可指定方法返回的HTTP状态码。"
  },
  {
    "module": "SpringMVC",
    "question": "Spring MVC的`MultipartResolver`的作用是（ ） ）",
    "type": "choice",
    "answer": "A",
    "options": [
      "A. 处理多部分请求（文件上传）",
      "B. 解析请求参数",
      "C. 处理多视图解析",
      "D. 实现请求转发"
    ],
    "explanation": "答案解析：`MultipartResolver`用于解析文件上传请求，Spring\n              Boot中自动配置`StandardServletMultipartResolver`。"
  },
  {
    "module": "SpringMVC",
    "question": "`@ControllerAdvice`注解的作用是（ ） ）",
    "type": "choice",
    "answer": "B",
    "options": [
      "A. 标记类为控制器",
      "B. 集中处理多个Controller的共性问题（如全局异常）",
      "C. 定义Controller的拦截规则",
      "D. 指定Controller的请求路径前缀"
    ],
    "explanation": "答案解析：`@ControllerAdvice`是全局控制器增强，可配合`@ExceptionHandler`、`@ModelAttribute`等实现全局处理。"
  },
  {
    "module": "SpringMVC",
    "question": "以下哪个方法在请求处理完成（包括视图渲染）后调用，无论是否发生异常？（ ） ）",
    "type": "choice",
    "answer": "C",
    "options": [
      "A. `preHandle`",
      "B. `postHandle`",
      "C. `afterCompletion`",
      "D. `destroy`"
    ],
    "explanation": "答案解析：`afterCompletion`在整个请求处理完成后调用，适合资源清理；若`preHandle`返回`false`，则不调用。"
  },
  {
    "module": "SpringMVC",
    "question": "Spring MVC中，`redirect:`前缀的作用是（ ） ）",
    "type": "choice",
    "answer": "B",
    "options": [
      "A. 转发到指定视图",
      "B. 重定向到指定URL",
      "C. 返回JSON数据",
      "D. 跳转到错误页面"
    ],
    "explanation": "答案解析：`return\n              \"redirect:/index\"`表示重定向到`/index`；`forward:`前缀表示转发。"
  },
  {
    "module": "SpringMVC",
    "question": "`@RequestParam`的`required`属性默认值是（ ） ）",
    "type": "choice",
    "answer": "A",
    "options": [
      "A. `true`",
      "B. `false`",
      "C. `null`",
      "D. 取决于参数类型"
    ],
    "explanation": "答案解析：`@RequestParam`默认要求参数必须存在，否则抛出异常；可设置`required=false`允许参数缺失。"
  },
  {
    "module": "SpringMVC",
    "question": "Spring MVC的`HandlerMapping`的作用是（ ） ）",
    "type": "choice",
    "answer": "A",
    "options": [
      "A. 将请求映射到对应的Controller方法",
      "B. 解析视图名",
      "C. 处理文件上传",
      "D. 拦截请求"
    ],
    "explanation": "答案解析：`HandlerMapping`负责根据请求路径查找对应的处理器（Controller方法），如`RequestMappingHandlerMapping`。"
  },
  {
    "module": "SpringMVC",
    "question": "以下哪个不是`HandlerInterceptor`接口的方法？（ ） ）",
    "type": "choice",
    "answer": "C",
    "options": [
      "A. `preHandle`",
      "B. `postHandle`",
      "C. `afterHandle`",
      "D. `afterCompletion`"
    ],
    "explanation": "答案解析：接口方法为`preHandle`、`postHandle`、`afterCompletion`，无`afterHandle`。"
  },
  {
    "module": "SpringMVC",
    "question": "`@ModelAttribute`注解标注在方法上时，其作用是（ ） ）",
    "type": "choice",
    "answer": "A",
    "options": [
      "A. 该方法在当前Controller的所有请求方法前执行，结果存入模型",
      "B. 绑定请求参数到模型对象",
      "C. 指定模型对象的名称",
      "D. 定义全局模型数据"
    ],
    "explanation": "答案解析：`@ModelAttribute`方法在Controller的每个请求方法执行前调用，常用于初始化公共模型数据。"
  },
  {
    "module": "SpringMVC",
    "question": "Spring MVC中，处理JSON数据通常依赖哪个库？（ ） ）",
    "type": "choice",
    "answer": "D",
    "options": [
      "A. Jackson",
      "B. Gson",
      "C. FastJSON",
      "D. 以上均可"
    ],
    "explanation": "答案解析：Spring\n              MVC支持Jackson（默认）、Gson、FastJSON等，通过对应的消息转换器实现JSON序列化。"
  },
  {
    "module": "SpringMVC",
    "question": "`@RequestMapping`的`consumes`属性用于（ ） ）",
    "type": "choice",
    "answer": "A",
    "options": [
      "A. 指定请求的Content-Type",
      "B. 指定响应的Content-Type",
      "C. 指定请求参数",
      "D. 指定请求方法"
    ],
    "explanation": "答案解析：`consumes =\n              \"application/json\"`表示仅处理Content-Type为JSON的请求；`produces`指定响应类型。"
  },
  {
    "module": "SpringMVC",
    "question": "Spring MVC的`View`接口的`render`方法的作用是（ ） ）",
    "type": "choice",
    "answer": "B",
    "options": [
      "A. 解析视图名",
      "B. 将模型数据渲染到响应中",
      "C. 处理请求参数",
      "D. 调用Controller方法"
    ],
    "explanation": "答案解析：`View.render(model, request, response)`负责将模型数据渲染到页面或响应体。"
  },
  {
    "module": "SpringMVC",
    "question": "以下哪个注解用于指定Controller方法返回的JSON数据的日期格式？（ ） ）",
    "type": "choice",
    "answer": "A",
    "options": [
      "A. `@JsonFormat`",
      "B. `@DateFormat`",
      "C. `@DateTimeFormat`",
      "D. `@JsonDate`"
    ],
    "explanation": "答案解析：`@JsonFormat(pattern =\n              \"yyyy-MM-dd\")`是Jackson注解，用于指定JSON日期格式。"
  },
  {
    "module": "SpringMVC",
    "question": "`@PathVariable`的`value`属性的作用是（ ） ）",
    "type": "choice",
    "answer": "B",
    "options": [
      "A. 指定参数是否必需",
      "B. 指定路径参数的名称（与URL中的占位符对应）",
      "C. 指定参数的默认值",
      "D. 指定参数的类型"
    ],
    "explanation": "答案解析：如`@PathVariable(value =\n              \"id\")`绑定URL中`{id}`的参数；若参数名与占位符一致，可省略。"
  },
  {
    "module": "SpringMVC",
    "question": "Spring MVC中，默认的视图解析器是（ ） ）",
    "type": "choice",
    "answer": "A",
    "options": [
      "A. `InternalResourceViewResolver`（JSP视图解析器）",
      "B. `FreeMarkerViewResolver`",
      "C. `VelocityViewResolver`",
      "D. `ThymeleafViewResolver`"
    ],
    "explanation": "答案解析：默认使用`InternalResourceViewResolver`解析JSP视图，其他视图解析器需手动配置。"
  },
  {
    "module": "SpringMVC",
    "question": "`@RequestParam`的`defaultValue`属性的作用是（ ） ）",
    "type": "choice",
    "answer": "B",
    "options": [
      "A. 指定参数的默认名称",
      "B. 当参数未传递时使用的默认值",
      "C. 指定参数的默认类型",
      "D. 标记参数为可选"
    ],
    "explanation": "答案解析：如`@RequestParam(defaultValue = \"1\") int\n              page`，当无page参数时，默认值为1。"
  },
  {
    "module": "SpringMVC",
    "question": "以下哪种方式不能实现Spring MVC的全局异常处理？（ ） ）",
    "type": "choice",
    "answer": "C",
    "options": [
      "A. `@ControllerAdvice` + `@ExceptionHandler`",
      "B. 实现`HandlerExceptionResolver`接口",
      "C. 在每个Controller中定义`@ExceptionHandler`",
      "D. 配置`SimpleMappingExceptionResolver`"
    ],
    "explanation": "答案解析：C是局部异常处理，仅作用于当前Controller；其他选项可实现全局处理。"
  },
  {
    "module": "SpringMVC",
    "question": "Spring MVC中，`Model`和`ModelMap`的关系是（ ） ）",
    "type": "choice",
    "answer": "A",
    "options": [
      "A. `Model`是接口，`ModelMap`是其实现类",
      "B. `ModelMap`是接口，`Model`是其实现类",
      "C. 两者无关系",
      "D. 两者是同一类的不同名称"
    ],
    "explanation": "答案解析：`Model`是接口，`ModelMap`是实现类，功能类似，用于存储模型数据。"
  },
  {
    "module": "SpringMVC",
    "question": "Spring MVC中，`DispatcherServlet`的核心职责不包括（ ） ）",
    "type": "choice",
    "answer": "B",
    "options": [
      "A. 接收HTTP请求",
      "B. 调用业务逻辑层方法",
      "C. 分发请求到Controller",
      "D. 处理响应并返回给客户端"
    ],
    "explanation": "答案解析：`DispatcherServlet`负责请求分发、视图解析等调度工作，业务逻辑由Controller调用Service层完成，并非其核心职责。"
  },
  {
    "module": "SpringMVC",
    "question": "`@RequestMapping`的`params`属性作用是（ ） ）",
    "type": "choice",
    "answer": "A",
    "options": [
      "A. 指定请求必须包含的参数（如`params = \"id\"`）",
      "B. 指定请求参数的类型",
      "C. 绑定请求参数到方法参数",
      "D. 过滤请求参数的字符集"
    ],
    "explanation": "答案解析：`params`用于限制请求必须包含指定参数，如`@RequestMapping(value =\n              \"/user\", params = \"action=delete\")`仅匹配含`action=delete`参数的请求。"
  },
  {
    "module": "SpringMVC",
    "question": "以下哪种方式不能将请求参数绑定到Controller方法的JavaBean参数？（ ） ）",
    "type": "choice",
    "answer": "D",
    "options": [
      "A. 表单字段名与JavaBean属性名一致",
      "B. 使用`@ModelAttribute`注解",
      "C. 使用`@RequestParam`注解逐个绑定",
      "D. 使用`@PathVariable`注解"
    ],
    "explanation": "答案解析：`@PathVariable`用于绑定URL路径参数，而非请求参数（如`?name=xxx`），无法直接绑定JavaBean。"
  },
  {
    "module": "SpringMVC",
    "question": "Spring MVC的`ViewResolver`接口的`resolveViewName`方法返回（ ） ）",
    "type": "choice",
    "answer": "B",
    "options": [
      "A. 视图名（String）",
      "B. `View`对象",
      "C. 模型数据（Model）",
      "D. 响应体（Response）"
    ],
    "explanation": "答案解析：`resolveViewName`根据逻辑视图名解析并返回`View`对象，由`View`负责渲染数据。"
  },
  {
    "module": "SpringMVC",
    "question": "`@ResponseBody`注解依赖的消息转换器接口是（ ） ）",
    "type": "choice",
    "answer": "A",
    "options": [
      "A. `HttpMessageConverter`",
      "B. `ViewResolver`",
      "C. `HandlerAdapter`",
      "D. `MessageSource`"
    ],
    "explanation": "答案解析：`@ResponseBody`通过`HttpMessageConverter`（如`MappingJackson2HttpMessageConverter`）将返回值转换为JSON等格式，写入响应体。"
  },
  {
    "module": "SpringMVC",
    "question": "拦截器的`preHandle`方法返回`false`时，后续流程会（ ） ）",
    "type": "choice",
    "answer": "B",
    "options": [
      "A. 继续执行Controller方法，但不执行`postHandle`",
      "B. 终止请求处理，不执行Controller和后续拦截器方法",
      "C. 仅跳过当前拦截器，继续执行其他拦截器",
      "D. 执行完所有拦截器后终止"
    ],
    "explanation": "答案解析：`preHandle`返回`false`会中断请求链，Controller方法、后续拦截器的`preHandle`、`postHandle`等均不执行。"
  },
  {
    "module": "SpringMVC",
    "question": "`@ModelAttribute`注解标注在方法参数上时，若未指定名称，默认的模型属性名称是（ ） ）",
    "type": "choice",
    "answer": "A",
    "options": [
      "A. 参数类型的首字母小写（如`User`→`user`）",
      "B. 参数的变量名",
      "C. 类名全称",
      "D. 无默认名称，必须显式指定"
    ],
    "explanation": "答案解析：如`public String save(@ModelAttribute User\n              user)`，模型中属性名为`user`（`User`类首字母小写）；可通过`@ModelAttribute(\"myUser\")`指定名称。"
  },
  {
    "module": "SpringMVC",
    "question": "以下哪个不是`HandlerInterceptor`接口的方法执行时机？（ ） ）",
    "type": "choice",
    "answer": "D",
    "options": [
      "A. Controller方法执行前（`preHandle`）",
      "B. Controller方法执行后、视图渲染前（`postHandle`）",
      "C. 视图渲染后（`afterCompletion`）",
      "D. 请求到达`DispatcherServlet`前（`beforeDispatch`）"
    ],
    "explanation": "答案解析：`HandlerInterceptor`无`beforeDispatch`方法，`preHandle`在`DispatcherServlet`分发请求到Controller前执行。"
  },
  {
    "module": "SpringMVC",
    "question": "Spring MVC中，`MultipartFile`的`transferTo（ ）ile dest)`方法的作用是（ ） ）",
    "type": "choice",
    "answer": "B",
    "options": [
      "A. 获取上传文件的输入流",
      "B. 将上传文件保存到目标路径",
      "C. 获取上传文件的大小",
      "D. 获取上传文件的原始文件名"
    ],
    "explanation": "答案解析：`transferTo`是便捷方法，用于将上传的临时文件保存到指定目标文件；需注意目标路径的权限。"
  },
  {
    "module": "SpringMVC",
    "question": "Spring MVC的`@RequestMapping`支持Ant风格路径，以下哪个符号表示匹配任意多级目录？（ ） ）",
    "type": "choice",
    "answer": "B",
    "options": [
      "A. `*`",
      "B. `**`",
      "C. `?`",
      "D. `#`"
    ],
    "explanation": "答案解析：Ant风格中，`*`匹配任意字符（单级），`**`匹配任意多级目录，`?`匹配单个字符。"
  },
  {
    "module": "SpringMVC",
    "question": "以下哪种情况`@RequestParam`会抛出`MissingServletRequestParameterException`？（ ） ）",
    "type": "choice",
    "answer": "B",
    "options": [
      "A. 参数值为`null`",
      "B. 参数未传递且`required = true`（默认）",
      "C. 参数类型不匹配",
      "D. 参数值为空字符串"
    ],
    "explanation": "答案解析：`@RequestParam`默认`required =\n              true`，若参数未传递则抛该异常；可设置`required = false`避免。"
  },
  {
    "module": "SpringMVC",
    "question": "`@ResponseStatus`注解标注在异常类上时，作用是（ ） ）",
    "type": "choice",
    "answer": "A",
    "options": [
      "A. 当该异常被抛出时，返回指定的HTTP状态码",
      "B. 标记异常为可处理异常",
      "C. 定义异常的错误消息",
      "D. 将异常信息写入响应体"
    ],
    "explanation": "答案解析：如`@ResponseStatus(code =\n              HttpStatus.NOT_FOUND)`标注在`ResourceNotFoundException`上，抛出该异常时返回404状态码。"
  },
  {
    "module": "SpringMVC",
    "question": "Spring MVC中，`Model`接口的`addAttribute`方法的作用是（ ） ）",
    "type": "choice",
    "answer": "A",
    "options": [
      "A. 向模型添加属性（键值对）",
      "B. 从模型中移除属性",
      "C. 替换模型中的属性",
      "D. 清空模型中的所有属性"
    ],
    "explanation": "答案解析：`addAttribute(\"user\",\n              user)`向模型添加名为`user`的属性，供视图访问；`removeAttribute`用于移除。"
  },
  {
    "module": "SpringMVC",
    "question": "以下哪个注解用于获取请求体中的JSON数据并绑定到方法参数？（ ） ）",
    "type": "choice",
    "answer": "B",
    "options": [
      "A. `@RequestParam`",
      "B. `@RequestBody`",
      "C. `@ModelAttribute`",
      "D. `@JsonBody`"
    ],
    "explanation": "答案解析：`@RequestBody`用于接收请求体中的数据（如JSON），通过消息转换器转换为Java对象，适用于POST/PUT等请求。"
  },
  {
    "module": "SpringMVC",
    "question": "`@SessionAttributes`注解标注的属性会存储在（ ） ）",
    "type": "choice",
    "answer": "B",
    "options": [
      "A. `HttpServletRequest`",
      "B. `HttpSession`",
      "C. `Model`",
      "D. `ServletContext`"
    ],
    "explanation": "答案解析：`@SessionAttributes(\"user\")`将模型中`user`属性存入`HttpSession`，实现跨请求共享（如多步骤表单）。"
  },
  {
    "module": "SpringMVC",
    "question": "`@RequestHeader`注解的`required`属性默认值是（ ） ）",
    "type": "choice",
    "answer": "A",
    "options": [
      "A. `true`",
      "B. `false`",
      "C. 取决于请求头类型",
      "D. 以上都不对"
    ],
    "explanation": "答案解析：`@RequestHeader`默认要求请求头必须存在，否则抛异常；可设置`required =\n              false`允许缺失。"
  },
  {
    "module": "SpringMVC",
    "question": "Spring MVC的`SimpleUrlHandlerMapping`的作用是（ ） ）",
    "type": "choice",
    "answer": "A",
    "options": [
      "A. 将URL路径直接映射到Controller实例（非注解式）",
      "B. 解析注解式Controller的`@RequestMapping`",
      "C. 处理静态资源请求",
      "D. 实现RESTful风格映射"
    ],
    "explanation": "答案解析：`SimpleUrlHandlerMapping`用于非注解式Controller的URL映射，如`/user\n              -> userController`，通过配置文件或代码指定映射关系。"
  },
  {
    "module": "SpringMVC",
    "question": "`@ExceptionHandler`注解的方法参数中，不能直接接收的是（ ） ）",
    "type": "choice",
    "answer": "D",
    "options": [
      "A. 异常对象（如`Exception e`）",
      "B. `HttpServletRequest`",
      "C. `Model`",
      "D. 视图名（`String viewName`）"
    ],
    "explanation": "答案解析：`@ExceptionHandler`方法可接收异常对象、请求/响应对象、模型等，视图名是方法的返回值，而非参数。"
  },
  {
    "module": "SpringMVC",
    "question": "Spring MVC中，`form`标签库的`path`属性作用是（ ） ）",
    "type": "choice",
    "answer": "A",
    "options": [
      "A. 绑定表单字段到模型对象的属性（如`path=\"name\"`绑定到`user.name`）",
      "B. 指定表单提交的URL路径",
      "C. 设置表单字段的名称",
      "D. 指定表单的编码方式"
    ],
    "explanation": "答案解析：`path`属性用于数据绑定，与模型对象的属性关联，自动回显值和处理错误信息。"
  },
  {
    "module": "SpringMVC",
    "question": "以下哪个不是`HttpMessageConverter`的实现类？（ ） ）",
    "type": "choice",
    "answer": "D",
    "options": [
      "A. `MappingJackson2HttpMessageConverter`（JSON）",
      "B. `StringHttpMessageConverter`（字符串）",
      "C. `ByteArrayHttpMessageConverter`（字节数组）",
      "D. `ViewResolverHttpMessageConverter`"
    ],
    "explanation": "答案解析：`ViewResolver`是视图解析器，与`HttpMessageConverter`（消息转换）无关，无此类实现。"
  },
  {
    "module": "SpringMVC",
    "question": "Spring MVC中，`@RequestMapping`的`headers`属性作用是（ ） ）",
    "type": "choice",
    "answer": "A",
    "options": [
      "A. 指定请求必须包含的请求头（如`headers = \"Content-Type=application/json\"`）",
      "B. 设置响应头",
      "C. 过滤请求头中的敏感信息",
      "D. 定义请求头的编码方式"
    ],
    "explanation": "答案解析：`headers`用于限制请求必须包含指定请求头，如仅处理JSON类型的请求。"
  },
  {
    "module": "SpringMVC",
    "question": "拦截器与过滤器（`Filter`）的区别是（ ） ）",
    "type": "choice",
    "answer": "D",
    "options": [
      "A. 拦截器基于Java反射，过滤器基于Servlet规范",
      "B. 拦截器仅在Spring MVC中生效，过滤器在所有Servlet容器中生效",
      "C. 拦截器可访问Spring容器中的Bean，过滤器不能",
      "D. 以上都对"
    ],
    "explanation": "答案解析：拦截器是Spring\n              MVC组件，基于AOP，可集成Spring功能；过滤器是Servlet规范，作用范围更广，不依赖Spring。"
  },
  {
    "module": "SpringMVC",
    "question": "Spring MVC中，当Controller方法返回`String`类型时，默认表示（ ） ）",
    "type": "choice",
    "answer": "B",
    "options": [
      "A. 响应体内容",
      "B. 逻辑视图名",
      "C. 重定向URL",
      "D. 模型属性名"
    ],
    "explanation": "答案解析：默认返回逻辑视图名（如`return\n              \"index\"`表示解析为`index.jsp`）；若加`@ResponseBody`则表示响应体，加`redirect:`表示重定向。"
  },
  {
    "module": "SpringMVC",
    "question": "DispatcherServlet的作用是接收请求，并将请求分发给对应的Controller。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  },
  {
    "module": "SpringMVC",
    "question": "在Spring MVC中，@RequestMapping注解只能用于类上，不能用于方法上。（ ） ）",
    "type": "judge",
    "answer": "F",
    "options": [
      "正确",
      "错误"
    ],
    "explanation": "答案解析：可用于类和方法上类上指定统一前缀方法上指定具体路径"
  },
  {
    "module": "SpringMVC",
    "question": "Spring MVC中，ModelAndView对象用于封装处理结果和视图名称。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  },
  {
    "module": "SpringMVC",
    "question": "使用@RequestParam注解可以获取URL路径中的参数，如`/user/{id}`中的id。（ ） ）",
    "type": "judge",
    "answer": "F",
    "options": [
      "正确",
      "错误"
    ],
    "explanation": "答案解析：@RequestParam获取请求参数@PathVariable获取URL路径参数"
  },
  {
    "module": "SpringMVC",
    "question": "Spring MVC中，Controller方法的返回值只能是ModelAndView类型。（ ） ）",
    "type": "judge",
    "answer": "F",
    "options": [
      "正确",
      "错误"
    ],
    "explanation": "答案解析：还可返回String（视图名、void、JSON对象等"
  },
  {
    "module": "SpringMVC",
    "question": "前端提交的表单数据，在Spring MVC中可通过实体类对象自动封装接收。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  },
  {
    "module": "SpringMVC",
    "question": "Spring MVC 中，`@ResponseBody` 注解可以将 Controller 方法的返回值直接转换为 JSON 格式并写入响应体。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  },
  {
    "module": "SpringMVC",
    "question": "视图解析器的 `prefix` 和 `suffix` 属性分别用于配置视图路径的前缀和后缀，如前缀 \"/WEB-INF/views/\"、后缀\n                \".jsp\"。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  },
  {
    "module": "SpringMVC",
    "question": "`@ExceptionHandler` 注解只能用于处理当前 Controller 中抛出的异常。（ ） ）",
    "type": "judge",
    "answer": "F",
    "options": [
      "正确",
      "错误"
    ],
    "explanation": "答案解析：配合 `@ControllerAdvice` 注解可实现全局异常处理"
  },
  {
    "module": "SpringMVC",
    "question": "Spring MVC 的拦截器需要实现 `HandlerInterceptor` 接口，并重写 `preHandle`、`postHandle` 和\n                `afterCompletion` 方法。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  },
  {
    "module": "SpringMVC",
    "question": "拦截器的`postHandle` 方法在 Controller 方法执行后、视图渲染前被调用，可在此修改 ModelAndView 对象。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  },
  {
    "module": "SpringMVC",
    "question": "使用 `@ModelAttribute` 注解可以将请求参数绑定到模型对象，并自动添加到模型中。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  },
  {
    "module": "SpringMVC",
    "question": "Spring Boot 中，文件上传需要依赖 `MultipartResolver`，且需在配置中手动注册该 Bean。（ ） ）",
    "type": "judge",
    "answer": "F",
    "options": [
      "正确",
      "错误"
    ],
    "explanation": "答案解析：Spring Boot 中会自动配置 `MultipartResolver`无需手动注册"
  },
  {
    "module": "SpringMVC",
    "question": "`@PathVariable` 注解支持设置参数是否必需，通过 `required` 属性控制，默认值为 `true`。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  },
  {
    "module": "SpringMVC",
    "question": "静态资源的访问路径可以通过 `spring.mvc.static-path-pattern` 配置，如配置为 \"/static/**\"。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  },
  {
    "module": "SpringMVC",
    "question": "`afterCompletion` 方法无论请求处理是否发生异常，都会在视图渲染完成后被调用。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  },
  {
    "module": "SpringMVC",
    "question": "Spring MVC 中，`DispatcherServlet` 的初始化参数 `contextConfigLocation` 用于指定 Spring MVC\n                的配置文件路径。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  },
  {
    "module": "SpringMVC",
    "question": "`@RequestHeader` 注解用于获取 HTTP 请求头中的信息，如获取 \"User-Agent\" 信息。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  },
  {
    "module": "SpringMVC",
    "question": "Controller 方法的参数中，`HttpServletRequest` 和 `HttpServletResponse` 对象可由 Spring MVC\n                自动注入。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  },
  {
    "module": "SpringMVC",
    "question": "视图解析器的 `order` 属性用于指定解析顺序，值越小优先级越高。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  },
  {
    "module": "SpringMVC",
    "question": "拦截器的 `preHandle` 方法返回 `false` 时，会终止请求的后续处理流程。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  },
  {
    "module": "SpringMVC",
    "question": "`@CookieValue` 注解用于获取 HTTP 请求中的 Cookie 信息。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  },
  {
    "module": "SpringMVC",
    "question": "当 Controller 方法返回 `ModelAndView` 时，若未设置视图名，Spring MVC 会默认使用请求路径作为视图名。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  },
  {
    "module": "MyBatis",
    "question": "MyBatis是一款（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ],
    "explanation": "答案解析：MyBatis是持久层ORM框架，支持自定义SQL，简化数据库操作。"
  },
  {
    "module": "MyBatis",
    "question": "MyBatis的核心配置文件通常命名为（ ） ）",
    "type": "choice",
    "answer": "B",
    "options": [
      "A. `mybatis.xml`",
      "B. `mybatis-config.xml`",
      "C. `config.xml`",
      "D. `mapper.xml`"
    ],
    "explanation": "答案解析：核心配置文件默认命名为`mybatis-config.xml`，用于配置数据源、映射器等。"
  },
  {
    "module": "MyBatis",
    "question": "MyBatis中，`#{}和${}`的区别是（ ） ）",
    "type": "choice",
    "answer": "B",
    "options": [
      "A. 两者无区别",
      "B. `#{} `是预编译占位符，可防止SQL注入；`${}`是字符串拼接，不能防止",
      "C. `${}`是预编译占位符，可防止SQL注入；`#{} `是字符串拼接，不能防止",
      "D. `#{} `用于数字类型，`${}`用于字符串类型"
    ],
    "explanation": "答案解析：`#{} `会替换为`?`，预编译处理，安全；`${}`直接拼接SQL，有注入风险，适合表名、排序字段等。"
  },
  {
    "module": "MyBatis",
    "question": "MyBatis的映射文件中，`<select>`标签的`resultType`属性用于（ ） ）",
    "type": "choice",
    "answer": "B",
    "options": [
      "A. 指定查询SQL",
      "B. 指定查询结果的封装类型",
      "C. 指定参数类型",
      "D. 指定主键生成策略"
    ],
    "explanation": "答案解析：`resultType`指定结果类型（如`int`、`User`），简单类型用`resultType`，复杂映射用`resultMap`。"
  },
  {
    "module": "MyBatis",
    "question": "Mapper接口与映射文件的关联是通过（ ） ）",
    "type": "choice",
    "answer": "A",
    "options": [
      "A. 映射文件的`namespace`属性与接口全类名一致",
      "B. 接口名与映射文件名一致",
      "C. 注解`@Mapper`指定映射文件路径",
      "D. 核心配置文件中显式配置关联"
    ],
    "explanation": "答案解析：映射文件的`namespace`必须等于Mapper接口的全类名，方法名与SQL标签的`id`一致。"
  },
  {
    "module": "MyBatis",
    "question": "MyBatis中，获取自动生成的主键值可通过（ ） ）",
    "type": "choice",
    "answer": "C",
    "options": [
      "A. `<insert>`标签的`useGeneratedKeys`和`keyProperty`属性",
      "B. `<selectKey>`标签",
      "C. A和B均可",
      "D. 无法获取"
    ],
    "explanation": "答案解析：自增主键用`useGeneratedKeys=\"true\" keyProperty=\"id\"`；非自增主键（如UUID）用`<selectKey>`。"
  },
  {
    "module": "MyBatis",
    "question": "MyBatis的一级缓存的作用域是（ ） ）",
    "type": "choice",
    "answer": "A",
    "options": [
      "A. `SqlSession`",
      "B. `Mapper`",
      "C. 应用级",
      "D. 全局"
    ],
    "explanation": "答案解析：一级缓存是`SqlSession`级，同一`SqlSession`内相同查询会缓存；二级缓存是`Mapper`级。"
  },
  {
    "module": "MyBatis",
    "question": "以下哪个标签用于定义可重用的SQL片段？（ ） ）",
    "type": "choice",
    "answer": "B",
    "options": [
      "A. `<include>`",
      "B. `<sql>`",
      "C. `<fragment>`",
      "D. `<part>`"
    ],
    "explanation": "答案解析：`<sql id=\"baseColumn\">id,name</sql>`定义片段，`<include refid=\"baseColumn\"/>`引入。"
  },
  {
    "module": "MyBatis",
    "question": "MyBatis的动态SQL中，`<where>`标签的作用是（ ） ）",
    "type": "choice",
    "answer": "B",
    "options": [
      "A. 生成`WHERE`关键字",
      "B. 自动去除`WHERE`后多余的`AND`或`OR`",
      "C. 条件判断",
      "D. 循环遍历集合"
    ],
    "explanation": "答案解析：`<where>`会自动添加`WHERE`，并去除内部SQL开头的`AND/OR`，简化条件拼接。"
  },
  {
    "module": "MyBatis",
    "question": "MyBatis的`SqlSession`的特点是（ ） ）",
    "type": "choice",
    "answer": "B",
    "options": [
      "A. 线程安全，可共享",
      "B. 非线程安全，每个线程单独创建",
      "C. 应用启动时创建，全局唯一",
      "D. 无需关闭，自动释放资源"
    ],
    "explanation": "答案解析：`SqlSession`非线程安全，需为每个线程创建，使用后需关闭（`close()`）。"
  },
  {
    "module": "MyBatis",
    "question": "动态SQL的`<foreach>`标签不支持以下哪种集合类型？（ ） ）",
    "type": "choice",
    "answer": "D",
    "options": [
      "A. List",
      "B. Array",
      "C. Map",
      "D. 基本数据类型（如int）"
    ],
    "explanation": "答案解析：`<foreach>`用于遍历集合（List、Array、Map），基本数据类型无法直接遍历。"
  },
  {
    "module": "MyBatis",
    "question": "MyBatis的`typeAliases`配置的作用是（ ） ）",
    "type": "choice",
    "answer": "A",
    "options": [
      "A. 给类名起别名，简化映射文件配置",
      "B. 定义SQL片段别名",
      "C. 给Mapper接口起别名",
      "D. 给表名起别名"
    ],
    "explanation": "答案解析：如`<typeAlias type=\"com.example.User\" alias=\"User\"/>`，映射文件中可直接用`resultType=\"User\"`。"
  },
  {
    "module": "MyBatis",
    "question": "以下哪个标签用于更新操作？（ ） ）",
    "type": "choice",
    "answer": "B",
    "options": [
      "A. `<insert>`",
      "B. `<update>`",
      "C. `<delete>`",
      "D. `<select>`"
    ],
    "explanation": "答案解析：`<insert>`插入，`<update>`更新，`<delete>`删除，`<select>`查询。"
  },
  {
    "module": "MyBatis",
    "question": "MyBatis的`resultMap`的`id`标签的作用是（ ） ）",
    "type": "choice",
    "answer": "B",
    "options": [
      "A. 指定结果集的唯一标识",
      "B. 指定主键字段的映射关系",
      "C. 定义结果集的名称",
      "D. 关联其他`resultMap`"
    ],
    "explanation": "答案解析：`<id>`标签用于映射主键字段，MyBatis会根据主键优化缓存和结果映射。"
  },
  {
    "module": "MyBatis",
    "question": "以下哪种方式不能实现MyBatis的接口绑定？（ ） ）",
    "type": "choice",
    "answer": "C",
    "options": [
      "A. 映射文件的`namespace`与接口全类名一致",
      "B. 在接口方法上使用`@Select`等注解",
      "C. 手动编写接口的实现类",
      "D. 核心配置文件中配置`mappers`"
    ],
    "explanation": "答案解析：MyBatis通过动态代理自动生成接口实现类，无需手动编写。"
  },
  {
    "module": "MyBatis",
    "question": "动态SQL的`<choose>`标签的作用是（ ） ）",
    "type": "choice",
    "answer": "B",
    "options": [
      "A. 循环遍历",
      "B. 条件判断（类似if-else if-else）",
      "C. 拼接`WHERE`条件",
      "D. 拼接`SET`条件"
    ],
    "explanation": "答案解析：`<choose>`包含`<when>`（if）和`<otherwise>`（else），实现多条件分支。"
  },
  {
    "module": "MyBatis",
    "question": "MyBatis的`SqlSessionFactory`的作用是（ ） ）",
    "type": "choice",
    "answer": "B",
    "options": [
      "A. 执行SQL语句",
      "B. 创建`SqlSession`实例",
      "C. 管理事务",
      "D. 映射SQL语句"
    ],
    "explanation": "答案解析：`SqlSessionFactory`是`SqlSession`的工厂，负责创建`SqlSession`，线程安全。"
  },
  {
    "module": "MyBatis",
    "question": "MyBatis的`@Mapper`注解的作用是（ ） ）",
    "type": "choice",
    "answer": "A",
    "options": [
      "A. 标记接口为Mapper接口，自动扫描",
      "B. 定义SQL语句",
      "C. 指定映射文件路径",
      "D. 开启二级缓存"
    ],
    "explanation": "答案解析：`@Mapper`标注接口后，MyBatis会自动扫描并生成代理实现类，替代核心配置文件中的`<mappers>`配置。"
  },
  {
    "module": "MyBatis",
    "question": "动态SQL的`<set>`标签的作用是（ ） ）",
    "type": "choice",
    "answer": "B",
    "options": [
      "A. 生成`SET`关键字",
      "B. 自动去除`SET`后多余的逗号",
      "C. 条件判断",
      "D. 用于更新操作的条件拼接"
    ],
    "explanation": "答案解析：`<set>`在更新时使用，自动添加`SET`并去除末尾逗号，如`<set><if test=\"name != null\">name=#{name},</if></set>`。"
  },
  {
    "module": "MyBatis",
    "question": "以下哪个标签用于处理批量插入？（ ） ）",
    "type": "choice",
    "answer": "A",
    "options": [
      "A. `<insert>` + `<foreach>`",
      "B. `<batch>`",
      "C. `<insertBatch>`",
      "D. `<bulkInsert>`"
    ],
    "explanation": "答案解析：MyBatis无专门批量插入标签，通过`<insert>`结合`<foreach>`遍历集合实现，如`insert into user values <foreach collection=\"list\" item=\"u\" separator=\",\">(#{u.id},#{u.name})</foreach>`。"
  },
  {
    "module": "MyBatis",
    "question": "MyBatis的`plugins`配置的作用是（ ） ）",
    "type": "choice",
    "answer": "A",
    "options": [
      "A. 引入外部插件（如分页插件）",
      "B. 配置数据源插件",
      "C. 配置缓存插件",
      "D. 配置日志插件"
    ],
    "explanation": "答案解析：`plugins`用于注册拦截器（如PageHelper分页插件），拦截SQL执行过程。"
  },
  {
    "module": "MyBatis",
    "question": "`resultMap`的`extends`属性的作用是（ ） ）",
    "type": "choice",
    "answer": "B",
    "options": [
      "A. 关联其他`resultMap`",
      "B. 继承其他`resultMap`的配置，减少冗余",
      "C. 指定父类实体",
      "D. 定义嵌套映射"
    ],
    "explanation": "答案解析：`extends`可继承另一个`resultMap`的配置，如`<resultMap id=\"userMap\" extends=\"baseMap\">`。"
  },
  {
    "module": "MyBatis",
    "question": "MyBatis的`@Param`注解的作用是（ ） ）",
    "type": "choice",
    "answer": "A",
    "options": [
      "A. 给方法参数命名，便于映射文件中引用",
      "B. 指定参数类型",
      "C. 标记参数为必需",
      "D. 开启参数缓存"
    ],
    "explanation": "答案解析：如`User selectById(@Param(\"id\") int userId)`，映射文件中可用`#{id}`引用参数。"
  },
  {
    "module": "MyBatis",
    "question": "MyBatis的映射文件中，`<delete>`标签的`parameterType`属性用于（ ） ）",
    "type": "choice",
    "answer": "B",
    "options": [
      "A. 指定删除SQL",
      "B. 指定参数类型",
      "C. 指定返回值类型",
      "D. 指定主键字段"
    ],
    "explanation": "答案解析：`parameterType`指定传入参数的类型（如`int`、`User`），可选，MyBatis可自动推断。"
  },
  {
    "module": "MyBatis",
    "question": "动态SQL的`<trim>`标签不包含以下哪个属性？（ ） ）",
    "type": "choice",
    "answer": "D",
    "options": [
      "A. `prefix`",
      "B. `suffix`",
      "C. `prefixOverrides`",
      "D. `loop`"
    ],
    "explanation": "答案解析：`<trim>`的属性包括`prefix`（前缀）、`suffix`（后缀）、`prefixOverrides`（去除前缀内容）、`suffixOverrides`（去除后缀内容），无`loop`。"
  },
  {
    "module": "MyBatis",
    "question": "以下哪个注解用于在Mapper接口方法上定义查询SQL？（ ） ）",
    "type": "choice",
    "answer": "C",
    "options": [
      "A. `@Insert`",
      "B. `@Update`",
      "C. `@Select`",
      "D. `@Delete`"
    ],
    "explanation": "答案解析：`@Select(\"select * from user where id = #{id}\")`用于定义查询SQL，其他注解对应增删改。"
  },
  {
    "module": "MyBatis",
    "question": "动态SQL的`<if>`标签的`test`属性用于（ ） ）",
    "type": "choice",
    "answer": "B",
    "options": [
      "A. 指定参数名称",
      "B. 条件判断表达式（OGNL）",
      "C. 指定SQL片段",
      "D. 循环变量名"
    ],
    "explanation": "答案解析：`test`属性值为OGNL表达式，如`<if test=\"name != null and name != ''\">`。"
  },
  {
    "module": "MyBatis",
    "question": "MyBatis的`resultType`和`resultMap`的关系是（ ） ）",
    "type": "choice",
    "answer": "B",
    "options": [
      "A. 两者不能同时使用",
      "B. `resultMap`是`resultType`的扩展，用于复杂映射",
      "C. `resultType`用于集合类型，`resultMap`用于对象类型",
      "D. 两者功能完全相同"
    ],
    "explanation": "答案解析：简单类型映射用`resultType`，复杂映射（如关联查询）用`resultMap`，两者互斥。"
  },
  {
    "module": "MyBatis",
    "question": "MyBatis的`SqlSession`的`selectOne`方法的作用是（ ） ）",
    "type": "choice",
    "answer": "A",
    "options": [
      "A. 执行查询，返回一个结果对象",
      "B. 执行查询，返回多个结果对象（List）",
      "C. 执行插入操作",
      "D. 执行更新操作"
    ],
    "explanation": "答案解析：`selectOne`返回单个对象，`selectList`返回集合；增删改用`insert`、`update`、`delete`。"
  },
  {
    "module": "MyBatis",
    "question": "以下哪种不是MyBatis的分页方式？（ ） ）",
    "type": "choice",
    "answer": "D",
    "options": [
      "A. SQL中直接写`LIMIT`（MySQL）或`ROWNUM`（Oracle）",
      "B. 使用分页插件（如PageHelper）",
      "C. 通过`RowBounds`类",
      "D. 使用`<page>`标签"
    ],
    "explanation": "答案解析：MyBatis无`<page>`标签，分页可通过SQL、插件或`RowBounds`实现。"
  },
  {
    "module": "MyBatis",
    "question": "MyBatis的`typeHandlers`配置的作用是（ ） ）",
    "type": "choice",
    "answer": "A",
    "options": [
      "A. 处理Java类型与数据库类型的转换",
      "B. 定义类型别名",
      "C. 处理动态SQL",
      "D. 配置缓存策略"
    ],
    "explanation": "答案解析：`typeHandlers`用于自定义类型转换（如Java的Date与数据库的VARCHAR转换）。"
  },
  {
    "module": "MyBatis",
    "question": "当MyBatis查询结果为多个对象时，若使用`selectOne`方法会（ ） ）",
    "type": "choice",
    "answer": "B",
    "options": [
      "A. 返回第一个对象",
      "B. 抛出`TooManyResultsException`",
      "C. 返回`null`",
      "D. 返回所有对象的集合"
    ],
    "explanation": "答案解析：`selectOne`期望返回单个结果，若查询到多个，会抛出`TooManyResultsException`。"
  },
  {
    "module": "MyBatis",
    "question": "MyBatis的映射文件中，`<insert>`标签的`keyProperty`属性作用是（ ） ）",
    "type": "choice",
    "answer": "B",
    "options": [
      "A. 指定插入SQL的主键字段名",
      "B. 指定JavaBean中接收自动生成主键值的属性名",
      "C. 指定主键生成策略",
      "D. 指定主键的数据类型"
    ],
    "explanation": "答案解析：`keyProperty`与`useGeneratedKeys=\"true\"`配合，将数据库自动生成的主键值回写到JavaBean的指定属性（如`keyProperty=\"id\"`）。"
  },
  {
    "module": "MyBatis",
    "question": "以下哪种情况适合使用`${}`而非`#{} `？（ ） ）",
    "type": "choice",
    "answer": "B",
    "options": [
      "A. 传递查询条件参数（如`where name = ?`）",
      "B. 传递表名或排序字段（如`order by ${column}`）",
      "C. 传递数字类型参数（如`where age = ?`）",
      "D. 传递字符串类型参数（如`where email = ?`）"
    ],
    "explanation": "答案解析：`${}`是字符串拼接，适合动态表名、排序字段等无法用预编译的场景；`#{} `是预编译占位符，防止SQL注入，适合参数传递。"
  },
  {
    "module": "MyBatis",
    "question": "动态SQL的`<choose>`标签中，`<otherwise>`标签的作用是（ ） ）",
    "type": "choice",
    "answer": "A",
    "options": [
      "A. 当所有`<when>`条件不满足时执行",
      "B. 当任意`<when>`条件满足时执行",
      "C. 无条件执行",
      "D. 嵌套其他`<choose>`标签"
    ],
    "explanation": "答案解析：`<choose>`类似Java的`switch`，`<when>`类似`case`，`<otherwise>`类似`default`，仅当所有`<when>`条件不满足时执行。"
  },
  {
    "module": "MyBatis",
    "question": "以下哪个标签用于在映射文件中定义接口方法与SQL的绑定？（ ） ）",
    "type": "choice",
    "answer": "B",
    "options": [
      "A. `<mapper>`",
      "B. `<select>`、`<insert>`等SQL标签（`id`与方法名一致）",
      "C. `<method>`",
      "D. `<bind>`"
    ],
    "explanation": "答案解析：映射文件的`namespace`与Mapper接口全类名一致，SQL标签的`id`与接口方法名一致，实现方法与SQL的绑定。"
  },
  {
    "module": "MyBatis",
    "question": "MyBatis的二级缓存默认的清除策略（`eviction`）是（ ） ）",
    "type": "choice",
    "answer": "A",
    "options": [
      "A. `LRU`（最近最少使用）",
      "B. `FIFO`（先进先出）",
      "C. `SOFT`（软引用）",
      "D. `WEAK`（弱引用）"
    ],
    "explanation": "答案解析：`<cache eviction=\"LRU\"/>`是默认配置，当缓存满时，移除最近最少使用的对象；其他策略需显式指定。"
  },
  {
    "module": "MyBatis",
    "question": "动态SQL的`<foreach>`标签中，`separator`属性的作用是（ ） ）",
    "type": "choice",
    "answer": "C",
    "options": [
      "A. 指定循环变量名",
      "B. 指定集合的类型（如`list`、`array`）",
      "C. 指定循环元素之间的分隔符（如逗号）",
      "D. 指定循环的开始和结束符号"
    ],
    "explanation": "答案解析：`separator`用于设置循环生成的SQL片段之间的分隔符，如批量插入时的逗号（`separator=\",\"`）。"
  },
  {
    "module": "MyBatis",
    "question": "以下哪种方式不能实现MyBatis的分页查询？（ ） ）",
    "type": "choice",
    "answer": "D",
    "options": [
      "A. SQL中直接添加`LIMIT`（MySQL）或`ROW_NUMBER()`（SQL Server）",
      "B. 使用`RowBounds`参数（`selectList`方法的第二个参数）",
      "C. 使用`pageHelper`插件",
      "D. 使用`<page>`标签"
    ],
    "explanation": "答案解析：MyBatis无`<page>`标签，分页需通过原生SQL、`RowBounds`或第三方插件实现。"
  },
  {
    "module": "MyBatis",
    "question": "MyBatis的映射文件中，`<selectKey>`标签的`order`属性取值为`BEFORE`时，表示（ ） ）",
    "type": "choice",
    "answer": "B",
    "options": [
      "A. 在插入语句执行后获取主键",
      "B. 在插入语句执行前获取主键（如UUID）",
      "C. 与插入语句同时执行",
      "D. 忽略主键生成"
    ],
    "explanation": "答案解析：`order=\"BEFORE\"`表示先执行`<selectKey>`中的SQL获取主键，再代入插入语句（适合UUID等非自增主键）；`AFTER`表示插入后获取（适合自增主键）。"
  },
  {
    "module": "MyBatis",
    "question": "关于MyBatis的`SqlSession`，以下说法错误的是（ ） ）",
    "type": "choice",
    "answer": "D",
    "options": [
      "A. `SqlSession`是线程不安全的，需为每个线程创建独立实例",
      "B. `SqlSession`的`close()`方法必须调用，否则可能导致连接泄漏",
      "C. `SqlSession`可通过`getMapper()`方法获取Mapper接口的代理对象",
      "D. `SqlSession`的`selectOne()`方法可返回多个结果对象"
    ],
    "explanation": "答案解析：`selectOne()`期望返回单个结果，若查询到多个会抛出`TooManyResultsException`；返回多个结果需用`selectList()`。"
  },
  {
    "module": "MyBatis",
    "question": "动态SQL的`<trim>`标签中，`suffixOverrides`属性的作用是（ ） ）",
    "type": "choice",
    "answer": "C",
    "options": [
      "A. 给SQL片段添加前缀",
      "B. 给SQL片段添加后缀",
      "C. 去除SQL片段末尾的指定内容（如逗号）",
      "D. 去除SQL片段开头的指定内容（如`AND`）"
    ],
    "explanation": "答案解析：`suffixOverrides=\",\"`表示去除SQL片段末尾的逗号，常用于动态`SET`或`IN`条件拼接。"
  },
  {
    "module": "MyBatis",
    "question": "以下哪个注解用于在Mapper接口方法上定义更新SQL？（ ） ）",
    "type": "choice",
    "answer": "A",
    "options": [
      "A. `@Update`",
      "B. `@Modify`",
      "C. `@UpdateByExample`",
      "D. `@UpdateMapping`"
    ],
    "explanation": "答案解析：`@Update(\"update user set name = #{name} where id = #{id}\")`用于定义更新SQL，是MyBatis的核心注解之一。"
  },
  {
    "module": "MyBatis",
    "question": "MyBatis的`mapper`接口方法参数为`Map`时，映射文件中引用参数的方式是（ ） ）",
    "type": "choice",
    "answer": "A",
    "options": [
      "A. `#{key}`（`key`为Map中的键）",
      "B. `#{map.key}`",
      "C. `#{param.key}`",
      "D. `#{0.key}`"
    ],
    "explanation": "答案解析：参数为`Map`时，直接通过`#{key}`引用Map中的值，如`Map<String, Object> params = new HashMap<>(); params.put(\"id\", 1);`，映射文件中用`#{id}`。"
  },
  {
    "module": "MyBatis",
    "question": "MyBatis的`@MapperScan`注解的作用是（ ） ）",
    "type": "choice",
    "answer": "A",
    "options": [
      "A. 扫描指定包下的Mapper接口，自动生成代理实现类",
      "B. 扫描映射文件",
      "C. 注册自定义类型处理器",
      "D. 开启二级缓存"
    ],
    "explanation": "答案解析：`@MapperScan(\"com.example.mapper\")`替代在每个Mapper接口上标注`@Mapper`，批量扫描指定包下的接口。"
  },
  {
    "module": "MyBatis",
    "question": "以下哪个标签用于在映射文件中引用其他SQL片段？（ ） ）",
    "type": "choice",
    "answer": "B",
    "options": [
      "A. `<import>`",
      "B. `<include>`",
      "C. `<ref>`",
      "D. `<use>`"
    ],
    "explanation": "答案解析：`<include refid=\"baseColumns\"/>`用于引用`<sql id=\"baseColumns\">id,name</sql>`定义的SQL片段，减少重复配置。"
  },
  {
    "module": "MyBatis",
    "question": "MyBatis的`lazyLoadingEnabled`全局配置的作用是（ ） ）",
    "type": "choice",
    "answer": "A",
    "options": [
      "A. 开启所有关联查询的延迟加载",
      "B. 开启一级缓存",
      "C. 开启二级缓存",
      "D. 开启批量操作优化"
    ],
    "explanation": "答案解析：`lazyLoadingEnabled=true`（默认`false`）开启全局延迟加载，关联对象在首次访问时才会查询数据库。"
  },
  {
    "module": "MyBatis",
    "question": "动态SQL的`<bind>`标签的作用是（ ） ）",
    "type": "choice",
    "answer": "A",
    "options": [
      "A. 定义一个变量并绑定到上下文，供后续SQL使用（如模糊查询）",
      "B. 绑定参数到JavaBean属性",
      "C. 关联其他`resultMap`",
      "D. 绑定Mapper接口方法"
    ],
    "explanation": "答案解析：如`<bind name=\"likeName\" value=\"'%' + name + '%'\"/>`，后续可通过`#{likeName}`使用，解决不同数据库模糊查询语法差异。"
  },
  {
    "module": "MyBatis",
    "question": "MyBatis的`@Result`注解的`column`属性作用是（ ） ）",
    "type": "choice",
    "answer": "B",
    "options": [
      "A. 指定JavaBean的属性名",
      "B. 指定数据库表的列名",
      "C. 指定结果映射的名称",
      "D. 指定关联查询的`resultMap`"
    ],
    "explanation": "答案解析：`@Result(column = \"user_name\", property = \"userName\")`表示数据库列`user_name`映射到JavaBean的`userName`属性。"
  },
  {
    "module": "MyBatis",
    "question": "MyBatis中，#{}和${}都可以用于参数占位符，且都能防止SQL注入。（ ） ）",
    "type": "judge",
    "answer": "F",
    "options": [
      "正确",
      "错误"
    ],
    "explanation": "答案解析：#{}可防止SQL注入${}是字符串拼接不能防止SQL注入"
  },
  {
    "module": "MyBatis",
    "question": "MyBatis支持一对一、一对多和多对多的关联查询映射。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  },
  {
    "module": "MyBatis",
    "question": "在MyBatis中，使用`<insert>`标签插入数据后，无法获取自动生成的主键值。（ ） ）",
    "type": "judge",
    "answer": "F",
    "options": [
      "正确",
      "错误"
    ],
    "explanation": "答案解析：可通过`useGeneratedKeys`和`keyProperty`属性获取自动生成的主键"
  },
  {
    "module": "MyBatis",
    "question": "MyBatis中，当查询结果为单个对象时，若查询无结果，会抛出NullPointerException。（ ） ）",
    "type": "judge",
    "answer": "F",
    "options": [
      "正确",
      "错误"
    ],
    "explanation": "答案解析：查询无结果时返回null不会抛出异常"
  },
  {
    "module": "MyBatis",
    "question": "MyBatis是一个ORM框架，可简化JDBC操作。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  },
  {
    "module": "MyBatis",
    "question": "一级缓存默认开启，作用范围是整个应用。（ ） ）",
    "type": "judge",
    "answer": "F",
    "options": [
      "正确",
      "错误"
    ],
    "explanation": "答案解析：一级缓存作用范围是SqlSession"
  },
  {
    "module": "MyBatis",
    "question": "`<insert>`标签的`useGeneratedKeys=\"true\"`可用于获取数据库自动生成的主键。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  },
  {
    "module": "MyBatis",
    "question": "MyBatis的映射文件中，`namespace`必须与Mapper接口的全类名一致。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  },
  {
    "module": "MyBatis",
    "question": "二级缓存默认开启，需要手动配置才能生效。（ ） ）",
    "type": "judge",
    "answer": "F",
    "options": [
      "正确",
      "错误"
    ],
    "explanation": "答案解析：二级缓存默认关闭需通过`<cache>`标签开启"
  },
  {
    "module": "MyBatis",
    "question": "动态SQL的`<if>`标签中，`test`属性支持OGNL表达式。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  },
  {
    "module": "MyBatis",
    "question": "`<collection>`标签用于处理一对一关联查询。（ ） ）",
    "type": "judge",
    "answer": "F",
    "options": [
      "正确",
      "错误"
    ],
    "explanation": "答案解析：`<collection>`处理一对多`<association>`处理一对一"
  },
  {
    "module": "MyBatis",
    "question": "MyBatis的`SqlSession`是线程安全的，可在多线程中共享。（ ） ）",
    "type": "judge",
    "answer": "F",
    "options": [
      "正确",
      "错误"
    ],
    "explanation": "答案解析：SqlSession线程不安全需为每个线程创建独立实例"
  },
  {
    "module": "MyBatis",
    "question": "`@Mapper`注解用于标记接口为MyBatis的Mapper接口。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  },
  {
    "module": "MyBatis",
    "question": "二级缓存中，不同namespace的缓存是相互独立的。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  },
  {
    "module": "MyBatis",
    "question": "`<trim>`标签的`prefix`属性用于给SQL片段添加前缀。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  },
  {
    "module": "MyBatis",
    "question": "当Mapper接口方法参数为多个时，必须使用`@Param`注解指定参数名。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ],
    "explanation": "答案解析：否则无法在映射文件中正确引用"
  },
  {
    "module": "MyBatis",
    "question": "`@ResultMap`注解用于引用XML中定义的`resultMap`。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  },
  {
    "module": "MyBatis",
    "question": "动态SQL的`<foreach>`标签中，`item`属性用于指定循环变量名。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  },
  {
    "module": "MyBatis",
    "question": "MyBatis支持通过接口方式和XML方式两种方式编写SQL。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  },
  {
    "module": "MyBatis",
    "question": "`<set>`标签可自动去除SQL语句末尾多余的逗号。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  },
  {
    "module": "MyBatis",
    "question": "`@Update`注解可直接在Mapper接口方法上定义更新SQL。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  },
  {
    "module": "MyBatis",
    "question": "映射文件中的`<sql>`标签用于定义可复用的SQL片段，通过`<include>`引用。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  },
  {
    "module": "MyBatis",
    "question": "MyBatis的`typeAliases`配置可给Java类型定义别名，简化映射文件编写。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  },
  {
    "module": "MyBatis",
    "question": "动态SQL的`<where>`标签会自动去除条件开头多余的`AND`或`OR`。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  },
  {
    "module": "MyBatis",
    "question": "`<foreach>`标签的`collection`属性在参数为List时，默认值是`list`。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  },
  {
    "module": "MyBatis",
    "question": "MyBatis的`mapperLocations`配置用于指定映射文件的位置。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  },
  {
    "module": "MyBatis",
    "question": "MyBatis的一级缓存和二级缓存都默认开启。（ ） ）",
    "type": "judge",
    "answer": "F",
    "options": [
      "正确",
      "错误"
    ],
    "explanation": "答案解析：一级缓存默认开启二级缓存默认关闭"
  },
  {
    "module": "MyBatis",
    "question": "二级缓存的`flushInterval`属性用于指定缓存的最大容量。（ ） ）",
    "type": "judge",
    "answer": "F",
    "options": [
      "正确",
      "错误"
    ],
    "explanation": "答案解析：`flushInterval`是自动刷新时间`size`是最大容量"
  },
  {
    "module": "MyBatis",
    "question": "映射文件中的`<delete>`标签不需要指定返回值类型，默认返回受影响的行数。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  },
  {
    "module": "MyBatis",
    "question": "MyBatis的插件可以修改SQL语句的执行逻辑。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ],
    "explanation": "答案解析：，通过拦截器可增强或修改原逻辑"
  },
  {
    "module": "MyBatis",
    "question": "当全局配置`mapUnderscoreToCamelCase=true`时，数据库列`user_name`会自动映射到Java属性`userName`。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  },
  {
    "module": "MyBatis",
    "question": "一级缓存的生命周期与`SqlSession`一致，`SqlSession`关闭后缓存失效。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  },
  {
    "module": "MyBatis",
    "question": "动态SQL的`<when>`标签可以嵌套`<if>`标签。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  },
  {
    "module": "MyBatis",
    "question": "映射文件中的`resultType`和`resultMap`可以同时使用。（ ） ）",
    "type": "judge",
    "answer": "F",
    "options": [
      "正确",
      "错误"
    ],
    "explanation": "答案解析：两者互斥只能选其一"
  },
  {
    "module": "MyBatis",
    "question": "`@MapperScan`注解可以批量扫描指定包下的Mapper接口，替代每个接口上的`@Mapper`。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  },
  {
    "module": "MyBatis",
    "question": "`<include>`标签的`refid`属性用于指定引用的SQL片段的`id`。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  },
  {
    "module": "MyBatis",
    "question": "MyBatis支持对存储过程的调用。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ],
    "explanation": "答案解析：通过`<select>`标签的`statementType=\"CALLABLE\"`实现"
  },
  {
    "module": "SpringBoot",
    "question": "Spring Boot的核心理念是（ ） ）",
    "type": "judge",
    "answer": "F",
    "options": [
      "正确",
      "错误"
    ],
    "explanation": "答案解析：Spring Boot通过“约定优于配置”简化开发，提供默认配置，减少手动配置。"
  },
  {
    "module": "SpringBoot",
    "question": "创建Spring Boot项目的常用工具是（ ） ）",
    "type": "choice",
    "answer": "A",
    "options": [
      "A. Spring Initializr",
      "B. Maven Archetype",
      "C. Gradle Template",
      "D. Eclipse Wizard"
    ],
    "explanation": "答案解析：Spring Initializr是官方推荐的项目创建工具，支持网页、IDEA等方式，自动生成骨架。"
  },
  {
    "module": "SpringBoot",
    "question": "Spring Boot的入口类需添加哪个注解？（ ） ）",
    "type": "choice",
    "answer": "C",
    "options": [
      "A. `@SpringBoot`",
      "B. `@SpringApplication`",
      "C. `@SpringBootApplication`",
      "D. `@EnableSpringBoot`"
    ],
    "explanation": "答案解析：入口类需标注`@SpringBootApplication`，该注解包含`@SpringBootConfiguration`、`@EnableAutoConfiguration`、`@ComponentScan`。"
  },
  {
    "module": "SpringBoot",
    "question": "Spring Boot默认内置的Web服务器是（ ） ）",
    "type": "choice",
    "answer": "B",
    "options": [
      "A. Nginx",
      "B. Tomcat",
      "C. Jetty",
      "D. Undertow"
    ],
    "explanation": "答案解析：默认内置Tomcat，可通过排除依赖切换为Jetty或Undertow。"
  },
  {
    "module": "SpringBoot",
    "question": "Spring Boot项目的配置文件默认名称不包括（ ） ）",
    "type": "choice",
    "answer": "D",
    "options": [
      "A. `application.properties`",
      "B. `application.yaml`",
      "C. `application.yml`",
      "D. `springboot.config`"
    ],
    "explanation": "答案解析：默认配置文件为`application.properties`、`application.yaml`、`application.yml`，无`springboot.config`。"
  },
  {
    "module": "SpringBoot",
    "question": "启动Spring Boot应用的方式不包括（ ） ）",
    "type": "choice",
    "answer": "D",
    "options": [
      "A. 运行入口类的`main`方法",
      "B. 打包为JAR包，用`java -jar`命令",
      "C. 部署到外部Tomcat（打包为WAR）",
      "D. 通过`maven install`命令"
    ],
    "explanation": "答案解析：`maven\n              install`是打包命令，不启动应用；启动需`spring-boot:run`或直接运行可执行JAR。"
  },
  {
    "module": "SpringBoot",
    "question": "`@Value`注解的作用是（ ） ）",
    "type": "choice",
    "answer": "A",
    "options": [
      "A. 注入配置文件中的属性值",
      "B. 定义Bean的名称",
      "C. 指定Bean的作用域",
      "D. 标记Bean为主要Bean"
    ],
    "explanation": "答案解析：`@Value(\"${app.name}\")`用于注入配置文件中的属性值，支持默认值（如`${app.name:default}`）。"
  },
  {
    "module": "SpringBoot",
    "question": "Spring Boot的`spring-boot-starter-parent`的作用是（ ） ）",
    "type": "choice",
    "answer": "A",
    "options": [
      "A. 提供依赖管理，统一版本",
      "B. 定义入口类",
      "C. 配置Web服务器",
      "D. 开启自动配置"
    ],
    "explanation": "答案解析：`spring-boot-starter-parent`作为父依赖，管理常用依赖的版本，避免版本冲突。"
  },
  {
    "module": "SpringBoot",
    "question": "配置文件中，修改默认服务器端口的属性是（ ） ）",
    "type": "choice",
    "answer": "A",
    "options": [
      "A. `server.port`",
      "B. `spring.server.port`",
      "C. `tomcat.port`",
      "D. `web.port`"
    ],
    "explanation": "答案解析：通过`server.port=8081`修改端口，默认8080。"
  },
  {
    "module": "SpringBoot",
    "question": "Spring Boot的`devtools`依赖的作用是（ ） ）",
    "type": "choice",
    "answer": "B",
    "options": [
      "A. 提供生产环境监控",
      "B. 实现热部署，加速开发",
      "C. 优化性能",
      "D. 处理数据库事务"
    ],
    "explanation": "答案解析：`spring-boot-devtools`提供热部署，修改代码后自动重启应用（快速重启）。"
  },
  {
    "module": "SpringBoot",
    "question": "以下哪个不是Spring Boot的Starter依赖？（ ） ）",
    "type": "choice",
    "answer": "D",
    "options": [
      "A. `spring-boot-starter-web`",
      "B. `spring-boot-starter-mybatis`",
      "C. `spring-boot-starter-logging`",
      "D. `spring-boot-starter-servlet`"
    ],
    "explanation": "答案解析：Starter是一组依赖的集合，`spring-boot-starter-web`包含Web相关依赖，无`spring-boot-starter-servlet`（servlet是Web的一部分）。"
  },
  {
    "module": "SpringBoot",
    "question": "Spring Boot项目打包为可执行JAR的插件是（ ） ）",
    "type": "choice",
    "answer": "B",
    "options": [
      "A. `maven-compiler-plugin`",
      "B. `spring-boot-maven-plugin`",
      "C. `maven-jar-plugin`",
      "D. `spring-boot-plugin`"
    ],
    "explanation": "答案解析：`spring-boot-maven-plugin`负责将项目打包为可执行JAR，包含依赖和启动类。"
  },
  {
    "module": "SpringBoot",
    "question": "激活不同环境配置（如dev、prod）的属性是（ ） ）",
    "type": "choice",
    "answer": "B",
    "options": [
      "A. `spring.profile.active`",
      "B. `spring.profiles.active`",
      "C. `spring.environment`",
      "D. `spring.active.profile`"
    ],
    "explanation": "答案解析：通过`spring.profiles.active=dev`激活`application-dev.properties`配置。"
  },
  {
    "module": "SpringBoot",
    "question": "Spring Boot的测试类通常使用哪个注解？（ ） ）",
    "type": "choice",
    "answer": "C",
    "options": [
      "A. `@Test`",
      "B. `@SpringTest`",
      "C. `@SpringBootTest`",
      "D. `@BootTest`"
    ],
    "explanation": "答案解析：`@SpringBootTest`用于Spring Boot测试，会加载应用上下文，支持自动注入Bean。"
  },
  {
    "module": "SpringBoot",
    "question": "静态资源默认存放目录不包括（ ） ）",
    "type": "choice",
    "answer": "C",
    "options": [
      "A. `src/main/resources/static`",
      "B. `src/main/resources/public`",
      "C. `src/main/resources/templates`",
      "D. `src/main/resources/resources`"
    ],
    "explanation": "答案解析：`templates`是模板文件（如Thymeleaf）存放目录，静态资源目录为static、public、resources。"
  },
  {
    "module": "SpringBoot",
    "question": "`application.yaml`与`application.properties`的区别是（ ） ）",
    "type": "choice",
    "answer": "A",
    "options": [
      "A. 语法不同，yaml用缩进，properties用`key=value`",
      "B. 优先级不同，yaml更高",
      "C. 支持的配置项不同",
      "D. yaml只支持Spring Boot 2.x"
    ],
    "explanation": "答案解析：两者功能相同，语法不同；优先级与格式无关，取决于文件位置。"
  },
  {
    "module": "SpringBoot",
    "question": "以下哪个依赖用于Spring Boot的Web开发？（ ） ）",
    "type": "choice",
    "answer": "A",
    "options": [
      "A. `spring-boot-starter-web`",
      "B. `spring-boot-starter-mvc`",
      "C. `spring-boot-starter-servlet`",
      "D. `spring-boot-starter-tomcat`"
    ],
    "explanation": "答案解析：`spring-boot-starter-web`包含Spring MVC、Tomcat等Web开发所需依赖。"
  },
  {
    "module": "SpringBoot",
    "question": "Spring Boot应用的默认上下文路径（ ）ontext Path）是（ ） ）",
    "type": "choice",
    "answer": "A",
    "options": [
      "A. `/`",
      "B. `/app`",
      "C. `/springboot`",
      "D. 空"
    ],
    "explanation": "答案解析：默认上下文路径为`/`，可通过`server.servlet.context-path=/api`修改。"
  },
  {
    "module": "SpringBoot",
    "question": "`@RestController`注解相比`@Controller`的区别是（ ） ）",
    "type": "choice",
    "answer": "D",
    "options": [
      "A. `@RestController`仅用于RESTful接口",
      "B. `@RestController`包含`@ResponseBody`，返回值直接作为响应体",
      "C. `@RestController`不支持视图解析",
      "D. 以上都对"
    ],
    "explanation": "答案解析：`@RestController` = `@Controller` +\n              `@ResponseBody`，适合RESTful接口，返回JSON等数据，不经过视图解析。"
  },
  {
    "module": "SpringBoot",
    "question": "Spring Boot中，关闭特定自动配置的注解属性是（ ） ）",
    "type": "choice",
    "answer": "C",
    "options": [
      "A. `@SpringBootApplication(exclude = XXX.class)`",
      "B. `@EnableAutoConfiguration(exclude = XXX.class)`",
      "C. A和B均可",
      "D. `@DisableAutoConfiguration`"
    ],
    "explanation": "答案解析：`@SpringBootApplication`包含`@EnableAutoConfiguration`，两者的`exclude`属性均可关闭特定自动配置。"
  },
  {
    "module": "SpringBoot",
    "question": "配置文件中，设置日志级别为DEBUG的属性是（ ） ）",
    "type": "choice",
    "answer": "B",
    "options": [
      "A. `logging.level=DEBUG`",
      "B. `logging.level.root=DEBUG`",
      "C. `log.level=DEBUG`",
      "D. `spring.logging.level=DEBUG`"
    ],
    "explanation": "答案解析：通过`logging.level.root=DEBUG`设置全局日志级别，`logging.level.com.example=DEBUG`设置指定包级别。"
  },
  {
    "module": "SpringBoot",
    "question": "Spring Boot的自动配置原理中，核心配置文件是（ ） ）",
    "type": "choice",
    "answer": "A",
    "options": [
      "A. `META-INF/spring.factories`",
      "B. `META-INF/spring.properties`",
      "C. `META-INF/spring.xml`",
      "D. `META-INF/auto-configure.properties`"
    ],
    "explanation": "答案解析：`spring.factories`文件中配置了自动配置类的全类名，Spring Boot启动时扫描并加载。"
  },
  {
    "module": "SpringBoot",
    "question": "以下哪个不是Spring Boot的核心特性？（ ） ）",
    "type": "choice",
    "answer": "D",
    "options": [
      "A. 自动配置",
      "B. Starter依赖",
      "C. 嵌入式服务器",
      "D. 底层ORM实现"
    ],
    "explanation": "答案解析：Spring Boot不提供ORM实现，需通过Starter集成MyBatis、JPA等。"
  },
  {
    "module": "SpringBoot",
    "question": "配置文件中，设置连接超时时间的属性是（ ） ）",
    "type": "choice",
    "answer": "A",
    "options": [
      "A. `server.connection-timeout`",
      "B. `spring.server.timeout`",
      "C. `tomcat.timeout`",
      "D. `connection.timeout`"
    ],
    "explanation": "答案解析：`server.connection-timeout=30000`设置连接超时时间（毫秒）。"
  },
  {
    "module": "SpringBoot",
    "question": "以下哪个注解用于标记配置类？（ ） ）",
    "type": "choice",
    "answer": "A",
    "options": [
      "A. `@Configuration`",
      "B. `@Config`",
      "C. `@BeanConfig`",
      "D. `@SpringConfig`"
    ],
    "explanation": "答案解析：`@Configuration`标记类为配置类，内部可通过`@Bean`定义Bean。"
  },
  {
    "module": "SpringBoot",
    "question": "Spring Boot中，`@Bean`注解的作用是（ ） ）",
    "type": "choice",
    "answer": "B",
    "options": [
      "A. 标记类为组件",
      "B. 在配置类中定义Bean",
      "C. 注入Bean",
      "D. 指定Bean的作用域"
    ],
    "explanation": "答案解析：`@Bean`用于配置类中，方法返回值作为Bean注册到容器中。"
  },
  {
    "module": "SpringBoot",
    "question": "外部化配置的优先级从高到低排序正确的是（ ） ）",
    "type": "choice",
    "answer": "A",
    "options": [
      "A. 命令行参数 > 系统环境变量 > 配置文件",
      "B. 配置文件 > 系统环境变量 > 命令行参数",
      "C. 系统环境变量 > 命令行参数 > 配置文件",
      "D. 命令行参数 > 配置文件 > 系统环境变量"
    ],
    "explanation": "答案解析：Spring Boot外部化配置优先级：命令行参数 > 系统环境变量 > 配置文件等。"
  },
  {
    "module": "SpringBoot",
    "question": "Spring Boot的`@EnableAutoConfiguration`注解的作用是（ ） ）",
    "type": "choice",
    "answer": "A",
    "options": [
      "A. 开启自动配置",
      "B. 开启组件扫描",
      "C. 定义配置类",
      "D. 启用Web功能"
    ],
    "explanation": "答案解析：`@EnableAutoConfiguration`是`@SpringBootApplication`的组成部分，负责开启自动配置。"
  },
  {
    "module": "SpringBoot",
    "question": "以下哪个依赖用于Spring Boot的测试？（ ） ）",
    "type": "choice",
    "answer": "A",
    "options": [
      "A. `spring-boot-starter-test`",
      "B. `spring-test`",
      "C. `junit`",
      "D. `mockito`"
    ],
    "explanation": "答案解析：`spring-boot-starter-test`包含JUnit、Mockito、Spring\n              Test等测试相关依赖。"
  },
  {
    "module": "SpringBoot",
    "question": "Spring Boot中，默认的JSON处理器是（ ） ）",
    "type": "choice",
    "answer": "B",
    "options": [
      "A. Gson",
      "B. Jackson",
      "C. FastJSON",
      "D. 无默认，需手动配置"
    ],
    "explanation": "答案解析：默认集成Jackson处理JSON，可通过排除依赖切换为Gson等。"
  },
  {
    "module": "SpringBoot",
    "question": "配置文件中，设置应用名称的属性是（ ） ）",
    "type": "choice",
    "answer": "A",
    "options": [
      "A. `spring.application.name`",
      "B. `app.name`",
      "C. `application.name`",
      "D. `server.name`"
    ],
    "explanation": "答案解析：`spring.application.name=myapp`设置应用名称，用于日志、监控等标识。"
  },
  {
    "module": "SpringBoot",
    "question": "Spring Boot的`@ComponentScan`注解的作用是（ ） ）",
    "type": "choice",
    "answer": "A",
    "options": [
      "A. 扫描指定包下的组件（@Component、@Controller等）",
      "B. 扫描配置文件",
      "C. 扫描自动配置类",
      "D. 扫描静态资源"
    ],
    "explanation": "答案解析：`@ComponentScan`指定扫描路径，默认扫描入口类所在包及子包。"
  },
  {
    "module": "SpringBoot",
    "question": "以下哪种方式不能修改Spring Boot的默认配置？（ ） ）",
    "type": "choice",
    "answer": "C",
    "options": [
      "A. 自定义配置文件",
      "B. 自定义自动配置类覆盖默认Bean",
      "C. 使用`@DisableAutoConfiguration`注解",
      "D. 命令行参数"
    ],
    "explanation": "答案解析：`@DisableAutoConfiguration`会禁用所有自动配置，不符合“修改默认配置”的需求；应针对性排除。"
  },
  {
    "module": "SpringBoot",
    "question": "Spring Boot的`Banner`（启动标语）可通过哪个属性关闭？（ ） ）",
    "type": "choice",
    "answer": "A",
    "options": [
      "A. `spring.banner.enabled=false`",
      "B. `banner.enabled=false`",
      "C. `spring.boot.banner=false`",
      "D. `server.banner=false`"
    ],
    "explanation": "答案解析：`spring.banner.enabled=false`关闭启动时的Banner标语。"
  },
  {
    "module": "SpringBoot",
    "question": "创建Spring Boot项目时，必须手动导入所有依赖包。（ ） ）",
    "type": "judge",
    "answer": "F",
    "options": [
      "正确",
      "错误"
    ],
    "explanation": "答案解析：可通过Spring Initializr自动导入所需依赖或在pom.xml中配置依赖坐标"
  },
  {
    "module": "SpringBoot",
    "question": "Spring\n                Boot应用的入口类需添加`@SpringBootApplication`注解，该注解包含了`@SpringBootConfiguration`、`@EnableAutoConfiguration`和`@ComponentScan`。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  },
  {
    "module": "SpringBoot",
    "question": "Spring Boot默认内置了Tomcat服务器，无需额外配置即可运行Web应用。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  },
  {
    "module": "SpringBoot",
    "question": "Spring Boot的`application.properties`配置文件只能放在src/main/resources目录下。（ ） ）",
    "type": "judge",
    "answer": "F",
    "options": [
      "正确",
      "错误"
    ],
    "explanation": "答案解析：还可放在src/main/resources/config目录、类路径根目录等位置且优先级不同"
  },
  {
    "module": "SpringBoot",
    "question": "Spring Boot中，使用`@Value`注解可以读取配置文件中的属性值。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  },
  {
    "module": "SpringBoot",
    "question": "Spring Boot默认支持RESTful风格的接口开发。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  },
  {
    "module": "SpringBoot",
    "question": "创建Spring Boot Web项目时，必须手动配置DispatcherServlet。（ ） ）",
    "type": "judge",
    "answer": "F",
    "options": [
      "正确",
      "错误"
    ],
    "explanation": "答案解析：Spring Boot自动配置DispatcherServlet无需手动配置"
  },
  {
    "module": "SpringBoot",
    "question": "Spring Boot应用打包成JAR包后，无法直接运行，需部署到外部服务器。（ ） ）",
    "type": "judge",
    "answer": "F",
    "options": [
      "正确",
      "错误"
    ],
    "explanation": "答案解析：JAR包内置服务器可通过`java -jar`命令直接运行"
  },
  {
    "module": "SpringBoot",
    "question": "MyBatis 的 ` ` 标签用于定义可重用的 SQL 片段，通过 ` ` 标签引入使用。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  },
  {
    "module": "SpringBoot",
    "question": "动态 SQL 中的 ` ` 标签可以自动去除其内部 SQL 语句开头的多余 AND 或 OR 关键字。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  },
  {
    "module": "SpringBoot",
    "question": "` ` 标签用于在插入数据时获取非自增主键的值，支持前置和后置获取两种方式。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  },
  {
    "module": "SpringBoot",
    "question": "MyBatis 的 Mapper 接口是通过 JDK 动态代理生成实现类的，无需手动编写实现代码。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  },
  {
    "module": "SpringBoot",
    "question": "动态 SQL 中的 ` ` 标签常用于遍历集合参数，生成 IN 条件语句或批量插入语句。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  },
  {
    "module": "SpringBoot",
    "question": "MyBatis 的二级缓存是 Mapper 级别的缓存，多个 SqlSession 可共享同一 Mapper 的缓存数据。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  },
  {
    "module": "SpringBoot",
    "question": "` ` 中的 ` ` 标签用于指定主键字段，MyBatis 会根据主键进行结果去重处理。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  },
  {
    "module": "SpringBoot",
    "question": "MyBatis 被称为半自动 ORM 框架，是因为其查询关联对象时需要手动编写 SQL 语句。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  },
  {
    "module": "SpringBoot",
    "question": "动态 SQL 的执行原理是通过 OGNL 表达式计算参数值，根据结果动态拼接 SQL 语句。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  },
  {
    "module": "SpringBoot",
    "question": "MyBatis 中，`SqlSessionFactory` 是线程安全的，而 `SqlSession` 是非线程安全的。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  },
  {
    "module": "SpringBoot",
    "question": "MyBatis的` ` 标签在更新操作中使用，可自动去除 SQL 语句末尾多余的逗号。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  },
  {
    "module": "SpringBoot",
    "question": "MyBatis 的 `mapper` 配置文件中，`namespace` 属性的值必须与对应的 Mapper 接口的全类名一致。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  },
  {
    "module": "SpringBoot",
    "question": "二级缓存需要实体类实现 `Serializable` 接口，否则无法进行序列化存储。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  },
  {
    "module": "SpringBoot",
    "question": "动态 SQL 中的 ` `、` `、` ` 标签组合使用，相当于 Java 中的 if-else if-else 逻辑。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  },
  {
    "module": "SpringBoot",
    "question": "使用 `@Mapper` 注解标注 Mapper 接口，可替代在核心配置文件中配置 ` ` 标签。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  },
  {
    "module": "SpringBoot",
    "question": "MyBatis 的一级缓存默认开启，当 SqlSession 关闭后，一级缓存中的数据会被清除。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  },
  {
    "module": "SpringBoot",
    "question": "Spring Initializr 是创建 Spring Boot 项目的常用工具，支持通过网页、IDEA 等多种方式使用。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  },
  {
    "module": "SpringBoot",
    "question": "Spring Boot 项目的 `pom.xml` 中，`spring-boot-starter-parent` 作为父依赖，提供了统一的依赖版本管理。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  },
  {
    "module": "SpringBoot",
    "question": "`application.yml` 配置文件采用缩进表示层级关系，相比 `application.properties` 更易读。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  },
  {
    "module": "SpringBoot",
    "question": "Spring Boot 支持通过 `spring.profiles.active` 配置激活不同环境的配置文件，如 dev、test、prod。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  },
  {
    "module": "SpringBoot",
    "question": "使用 `@SpringBootTest` 注解可以进行 Spring Boot 应用的单元测试和集成测试。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  },
  {
    "module": "SpringBoot",
    "question": "Spring Boot 项目打包为 WAR 包时，需在入口类中继承 `SpringBootServletInitializer` 并重写 `configure`\n                方法。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  },
  {
    "module": "SpringBoot",
    "question": "`@ConfigurationProperties` 注解可以将配置文件中的属性批量绑定到实体类对象中。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  },
  {
    "module": "SpringBoot",
    "question": "Spring Boot 默认的服务器端口是 8080，可通过 `server.port` 配置修改。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  },
  {
    "module": "SpringBoot",
    "question": "启动 Spring Boot 应用时，通过 `--spring.profiles.active=dev` 命令行参数可指定激活 dev 环境配置。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  },
  {
    "module": "SpringBoot",
    "question": "Spring Boot 的 `spring-boot-devtools` 依赖提供了热部署功能，可加速开发过程。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  },
  {
    "module": "SpringBoot",
    "question": "Spring Boot 项目中，静态资源默认存放于 `src/main/resources/static`、`public`、`resources` 目录下。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  },
  {
    "module": "SpringBoot",
    "question": "`application.properties` 中，配置属性的键名不区分大小写，如 `server.port` 和 `SERVER.PORT` 效果相同。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  },
  {
    "module": "SpringBoot",
    "question": "使用 `spring-boot-maven-plugin` 插件可以将 Spring Boot 项目打包为可执行 JAR 包。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  },
  {
    "module": "SpringBoot",
    "question": "Spring Boot 自动配置的本质是根据类路径下的依赖自动注册对应的 Bean。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  },
  {
    "module": "SpringBoot",
    "question": "Spring Boot 应用可通过 `SpringApplication.run（ ）pplication.class, args)` 方法启动。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  },
  {
    "module": "SpringBoot",
    "question": "不同位置的配置文件优先级不同，`src/main/resources/config` 目录下的配置文件优先级高于 `src/main/resources`\n                目录。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  },
  {
    "module": "SpringBoot",
    "question": "Spring Boot 支持通过 `logging.level.root` 配置全局日志级别，如 DEBUG、INFO、ERROR。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  },
  {
    "module": "SpringBoot",
    "question": "创建 Spring Boot Web 项目时，引入 `spring-boot-starter-web` 依赖即可自动集成 Spring MVC 和\n                Tomcat。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  },
  {
    "module": "SpringBoot",
    "question": "`@RestController` 注解是 `@Controller` 和 `@ResponseBody` 注解的组合。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  },
  {
    "module": "SpringBoot核心",
    "question": "`@ConditionalOnClass`注解的作用是（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ],
    "explanation": "答案解析：`@ConditionalOnClass(DataSource.class)`表示类路径有`DataSource`时，配置生效。"
  },
  {
    "module": "SpringBoot核心",
    "question": "Spring Boot Actuator的作用是（ ） ）",
    "type": "choice",
    "answer": "B",
    "options": [
      "A. 自动配置应用",
      "B. 监控和管理应用",
      "C. 处理HTTP请求",
      "D. 优化应用性能"
    ],
    "explanation": "答案解析：Actuator提供端点（如`/health`、`/info`）用于监控应用健康、指标等。"
  },
  {
    "module": "SpringBoot核心",
    "question": "`@ConditionalOnMissingBean`注解的作用是（ ） ）",
    "type": "choice",
    "answer": "B",
    "options": [
      "A. 当容器中存在指定Bean时，才注册当前Bean",
      "B. 当容器中不存在指定Bean时，才注册当前Bean",
      "C. 忽略指定Bean的注册",
      "D. 强制注册指定Bean"
    ],
    "explanation": "答案解析：用于自动配置中，确保用户自定义Bean优先于默认Bean（用户定义后，默认Bean不注册）。"
  },
  {
    "module": "SpringBoot核心",
    "question": "Spring Boot 2.x默认使用的数据源是（ ） ）",
    "type": "choice",
    "answer": "C",
    "options": [
      "A. DBCP2",
      "B. C3P0",
      "C. HikariCP",
      "D. Tomcat JDBC"
    ],
    "explanation": "答案解析：Spring Boot 2.x默认使用HikariCP，性能优于传统数据源。"
  },
  {
    "module": "SpringBoot核心",
    "question": "Spring Boot整合MyBatis时，需引入的Starter依赖是（ ） ）",
    "type": "choice",
    "answer": "A",
    "options": [
      "A. `mybatis-spring-boot-starter`",
      "B. `spring-boot-starter-mybatis`",
      "C. `mybatis-spring-starter`",
      "D. `spring-mybatis-boot-starter`"
    ],
    "explanation": "答案解析：官方Starter为`mybatis-spring-boot-starter`，提供自动配置。"
  },
  {
    "module": "SpringBoot核心",
    "question": "`@ConditionalOnProperty`注解的作用是（ ） ）",
    "type": "choice",
    "answer": "A",
    "options": [
      "A. 当指定属性存在且值匹配时，配置生效",
      "B. 当指定属性不存在时，配置生效",
      "C. 忽略指定属性",
      "D. 强制设置属性值"
    ],
    "explanation": "答案解析：`@ConditionalOnProperty(name =\n              \"spring.datasource.enabled\", havingValue = \"true\")`表示属性匹配时生效。"
  },
  {
    "module": "SpringBoot核心",
    "question": "Actuator的端点路径默认前缀是（ ） ）",
    "type": "choice",
    "answer": "A",
    "options": [
      "A. `/actuator`",
      "B. `/monitor`",
      "C. `/health`",
      "D. 无前缀"
    ],
    "explanation": "答案解析：默认端点路径为`/actuator/health`、`/actuator/info`等，可通过`management.endpoints.web.base-path`修改。"
  },
  {
    "module": "SpringBoot核心",
    "question": "`@SpringBootConfiguration`注解的本质是（ ） ）",
    "type": "choice",
    "answer": "A",
    "options": [
      "A. `@Configuration`",
      "B. `@Component`",
      "C. `@EnableAutoConfiguration`",
      "D. `@ComponentScan`"
    ],
    "explanation": "答案解析：`@SpringBootConfiguration`是`@Configuration`的特殊形式，标识当前类为Spring Boot配置类。"
  },
  {
    "module": "SpringBoot核心",
    "question": "`@ConditionalOnWebApplication`注解的作用是（ ） ）",
    "type": "choice",
    "answer": "A",
    "options": [
      "A. 当应用是Web应用时，配置生效",
      "B. 当应用是非Web应用时，配置生效",
      "C. 配置Web应用的参数",
      "D. 禁用Web应用自动配置"
    ],
    "explanation": "答案解析：用于Web相关自动配置（如`DispatcherServletAutoConfiguration`），仅在Web应用中生效。"
  },
  {
    "module": "SpringBoot核心",
    "question": "Spring Boot的`DataSourceAutoConfiguration`的作用是（ ） ）",
    "type": "choice",
    "answer": "A",
    "options": [
      "A. 自动配置数据源",
      "B. 自动配置事务管理器",
      "C. 自动配置JPA",
      "D. 自动配置MyBatis"
    ],
    "explanation": "答案解析：根据类路径下的驱动和配置（`spring.datasource.*`）自动配置数据源。"
  },
  {
    "module": "SpringBoot核心",
    "question": "`@EnableConfigurationProperties`注解的作用是（ ） ）",
    "type": "choice",
    "answer": "A",
    "options": [
      "A. 开启`@ConfigurationProperties`注解的支持",
      "B. 定义配置属性",
      "C. 加载配置文件",
      "D. 覆盖默认配置"
    ],
    "explanation": "答案解析：需配合`@ConfigurationProperties`使用，使属性绑定生效（如`@EnableConfigurationProperties(UserProperties.class)`）。"
  },
  {
    "module": "SpringBoot核心",
    "question": "`@ConditionalOnMissingClass`注解的作用是（ ） ）",
    "type": "choice",
    "answer": "B",
    "options": [
      "A. 当类路径下存在指定类时，配置生效",
      "B. 当类路径下不存在指定类时，配置生效",
      "C. 当容器中不存在指定Bean时，配置生效",
      "D. 忽略指定类"
    ],
    "explanation": "答案解析：与`@ConditionalOnClass`相反，类路径无指定类时配置生效。"
  },
  {
    "module": "SpringBoot核心",
    "question": "Spring Boot整合Spring Data JPA时，需引入的Starter依赖是（ ） ）",
    "type": "choice",
    "answer": "A",
    "options": [
      "A. `spring-boot-starter-data-jpa`",
      "B. `jpa-spring-boot-starter`",
      "C. `spring-data-jpa-starter`",
      "D. `spring-jpa-boot-starter`"
    ],
    "explanation": "答案解析：官方Starter为`spring-boot-starter-data-jpa`，自动配置JPA相关Bean。"
  },
  {
    "module": "SpringBoot核心",
    "question": "`@ConditionalOnExpression`注解的作用是（ ） ）",
    "type": "choice",
    "answer": "A",
    "options": [
      "A. 通过SpEL表达式判断是否生效配置",
      "B. 通过正则表达式判断是否生效配置",
      "C. 通过SQL表达式判断是否生效配置",
      "D. 通过EL表达式判断是否生效配置"
    ],
    "explanation": "答案解析：`@ConditionalOnExpression(\"${spring.cache.enabled:true} &&\n              '${spring.cache.type}' != 'none'\")`通过SpEL表达式判断。"
  },
  {
    "module": "SpringBoot核心",
    "question": "Spring Boot的自动配置类通常位于哪个依赖中？（ ） ）",
    "type": "choice",
    "answer": "B",
    "options": [
      "A. `spring-boot-starter`",
      "B. `spring-boot-autoconfigure`",
      "C. `spring-boot`",
      "D. `spring-core`"
    ],
    "explanation": "答案解析：`spring-boot-autoconfigure`包含大部分自动配置类，是核心依赖。"
  },
  {
    "module": "SpringBoot核心",
    "question": "`@AutoConfigureOrder`注解的作用是（ ） ）",
    "type": "choice",
    "answer": "A",
    "options": [
      "A. 指定自动配置类的加载顺序（值越小越先加载）",
      "B. 指定自动配置类的优先级（值越大越优先）",
      "C. 禁用自动配置类的排序",
      "D. 标记自动配置类为主要配置"
    ],
    "explanation": "答案解析：`@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)`指定配置类优先加载。"
  },
  {
    "module": "SpringBoot核心",
    "question": "`@ConfigurationProperties`的`prefix`属性的作用是（ ） ）",
    "type": "choice",
    "answer": "B",
    "options": [
      "A. 指定配置文件的路径",
      "B. 指定属性的前缀，用于批量绑定",
      "C. 指定Bean的名称前缀",
      "D. 指定扫描包的前缀"
    ],
    "explanation": "答案解析：`@ConfigurationProperties(prefix =\n              \"user\")`绑定`user.name`、`user.age`等属性到实体类。"
  },
  {
    "module": "SpringBoot核心",
    "question": "`@Conditional`注解的作用是（ ） ）",
    "type": "choice",
    "answer": "A",
    "options": [
      "A. 自定义条件判断，决定配置是否生效",
      "B. 强制配置生效",
      "C. 禁用配置",
      "D. 标记配置类"
    ],
    "explanation": "答案解析：`@Conditional(MyCondition.class)`，`MyCondition`实现`Condition`接口，自定义判断逻辑。"
  },
  {
    "module": "SpringBoot核心",
    "question": "Spring Boot整合Redis时，需引入的Starter依赖是（ ） ）",
    "type": "choice",
    "answer": "A",
    "options": [
      "A. `spring-boot-starter-data-redis`",
      "B. `redis-spring-boot-starter`",
      "C. `spring-redis-boot-starter`",
      "D. `spring-data-redis-starter`"
    ],
    "explanation": "答案解析：官方Starter为`spring-boot-starter-data-redis`，自动配置`RedisTemplate`等。"
  },
  {
    "module": "SpringBoot核心",
    "question": "自动配置类的命名规范通常是（ ） ）",
    "type": "choice",
    "answer": "A",
    "options": [
      "A. `XxxAutoConfiguration`",
      "B. `AutoConfigurationXxx`",
      "C. `XxxConfiguration`",
      "D. `ConfigurationXxx`"
    ],
    "explanation": "答案解析：自动配置类通常以`XxxAutoConfiguration`命名（如`DataSourceAutoConfiguration`）。"
  },
  {
    "module": "SpringBoot核心",
    "question": "`@ConditionalOnResource`注解的作用是（ ） ）",
    "type": "choice",
    "answer": "A",
    "options": [
      "A. 当指定资源存在时，配置生效",
      "B. 当指定资源不存在时，配置生效",
      "C. 加载指定资源",
      "D. 忽略指定资源"
    ],
    "explanation": "答案解析：`@ConditionalOnResource(resources =\n              \"classpath:application-dev.properties\")`表示资源存在时生效。"
  },
  {
    "module": "SpringBoot核心",
    "question": "Spring Boot中，配置Jackson日期格式的属性是（ ） ）",
    "type": "choice",
    "answer": "A",
    "options": [
      "A. `spring.jackson.date-format=yyyy-MM-dd HH:mm:ss`",
      "B. `jackson.date-format=yyyy-MM-dd HH:mm:ss`",
      "C. `spring.date-format=yyyy-MM-dd HH:mm:ss`",
      "D. `date-format=yyyy-MM-dd HH:mm:ss`"
    ],
    "explanation": "答案解析：通过`spring.jackson.date-format`配置JSON日期序列化格式。"
  },
  {
    "module": "SpringBoot核心",
    "question": "`@EnableAutoConfiguration`注解的`excludeName`属性用于（ ） ）",
    "type": "choice",
    "answer": "A",
    "options": [
      "A. 排除指定类名的自动配置类（全类名字符串）",
      "B. 排除指定类型的自动配置类",
      "C. 包含指定自动配置类",
      "D. 重命名自动配置类"
    ],
    "explanation": "答案解析：`exclude`接收Class对象，`excludeName`接收全类名字符串（如`excludeName =\n              \"org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration\"`）。"
  },
  {
    "module": "SpringBoot核心",
    "question": "Actuator的`/shutdown`端点的作用是（ ） ）",
    "type": "choice",
    "answer": "B",
    "options": [
      "A. 查看应用状态",
      "B. 关闭应用（需POST请求）",
      "C. 重启应用",
      "D. 清理缓存"
    ],
    "explanation": "答案解析：`/shutdown`默认关闭，开启后通过POST请求可优雅关闭应用。"
  },
  {
    "module": "SpringBoot核心",
    "question": "Spring Boot的`@Bean`方法的`initMethod`和`destroyMethod`属性的作用是（ ） ）",
    "type": "choice",
    "answer": "A",
    "options": [
      "A. 指定Bean的初始化和销毁方法",
      "B. 指定Bean的作用域",
      "C. 指定Bean的依赖",
      "D. 指定Bean的名称"
    ],
    "explanation": "答案解析：`@Bean(initMethod = \"init\", destroyMethod =\n              \"destroy\")`指定初始化和销毁方法。"
  },
  {
    "module": "SpringBoot核心",
    "question": "整合Thymeleaf模板引擎时，需引入的Starter依赖是（ ） ）",
    "type": "choice",
    "answer": "A",
    "options": [
      "A. `spring-boot-starter-thymeleaf`",
      "B. `thymeleaf-spring-boot-starter`",
      "C. `spring-thymeleaf-boot-starter`",
      "D. `thymeleaf-starter`"
    ],
    "explanation": "答案解析：官方Starter为`spring-boot-starter-thymeleaf`，自动配置Thymeleaf。"
  },
  {
    "module": "SpringBoot核心",
    "question": "Spring Boot 2.x中，配置应用类型为非Web应用的属性是（ ） ）",
    "type": "choice",
    "answer": "A",
    "options": [
      "A. `spring.main.web-application-type=none`",
      "B. `spring.web.enabled=false`",
      "C. `server.enabled=false`",
      "D. `spring.application.type=non-web`"
    ],
    "explanation": "答案解析：`web-application-type`可选值：`SERVLET`（默认）、`REACTIVE`、`none`（非Web）。"
  },
  {
    "module": "SpringBoot核心",
    "question": "在Spring Boot中，若需禁用某个自动配置类，可使用`@SpringBootApplication`注解的`exclude`属性。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  },
  {
    "module": "SpringBoot核心",
    "question": "Spring Boot中，使用`@Configuration`和`@Bean`注解可以替代XML配置，实现Bean的定义。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  },
  {
    "module": "SpringBoot核心",
    "question": "Spring Boot Actuator可以监控和管理Spring Boot应用，默认开启所有监控端点。（ ） ）",
    "type": "judge",
    "answer": "F",
    "options": [
      "正确",
      "错误"
    ],
    "explanation": "答案解析：默认只开启/health和/info端点其他端点需手动配置开启"
  },
  {
    "module": "SpringBoot核心",
    "question": "Spring Boot支持多种配置文件格式，包括properties、yaml和yml，其中yaml格式的配置文件优先级最高。（ ） ）",
    "type": "judge",
    "answer": "F",
    "options": [
      "正确",
      "错误"
    ],
    "explanation": "答案解析：配置文件优先级与格式无关与文件位置和加载顺序有关"
  },
  {
    "module": "SpringBoot核心",
    "question": "在Spring Boot中，使用`@RestController`注解的类，其方法返回值默认会被转换为JSON格式。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ],
    "explanation": "答案解析：`@RestController`包含`@Controller`和`@ResponseBody`，`@ResponseBody`指定返回值为响应体，默认转JSON"
  },
  {
    "module": "SpringBoot核心",
    "question": "Spring Boot的外部化配置中，命令行参数的优先级高于配置文件的优先级。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  },
  {
    "module": "SpringBoot核心",
    "question": "Spring Boot中，整合MyBatis时，必须手动配置SqlSessionFactory和SqlSessionTemplate。（ ） ）",
    "type": "judge",
    "answer": "F",
    "options": [
      "正确",
      "错误"
    ],
    "explanation": "答案解析：通过mybatis-spring-boot-starter依赖可实现自动配置无需手动配置"
  },
  {
    "module": "SpringBoot核心",
    "question": "Spring Boot 2.x版本默认使用的ORM框架是JPA，而非MyBatis。（ ） ）",
    "type": "judge",
    "answer": "F",
    "options": [
      "正确",
      "错误"
    ],
    "explanation": "答案解析：Spring Boot默认不强制指定ORM框架JPA和MyBatis需通过对应Starter依赖引入后使用"
  },
  {
    "module": "SpringBoot核心",
    "question": "Spring Boot 的自动配置类通常位于 `spring-boot-autoconfigure` 依赖的 `META-INF/spring.factories`\n                文件中。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  },
  {
    "module": "SpringBoot核心",
    "question": "`@ConditionalOnClass` 注解表示当类路径下存在指定类时，才会生效对应的自动配置。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  },
  {
    "module": "SpringBoot核心",
    "question": "Spring Boot 整合 MyBatis 时，引入 `mybatis-spring-boot-starter` 依赖即可实现自动配置。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  },
  {
    "module": "SpringBoot核心",
    "question": "Spring Boot外部化配置中，系统环境变量的优先级高于配置文件的优先级。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  },
  {
    "module": "SpringBoot核心",
    "question": "`@EnableAutoConfiguration` 注解用于开启 Spring Boot 的自动配置功能。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  },
  {
    "module": "SpringBoot核心",
    "question": "`@ConditionalOnWebApplication` 注解表示当应用是 Web 应用时，自动配置才会生效。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  },
  {
    "module": "SpringBoot核心",
    "question": "Spring Boot 2.x 中，默认使用 HikariCP 作为数据源，相比传统数据源性能更优。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  },
  {
    "module": "SpringBoot核心",
    "question": "自动配置类可以通过 `@AutoConfigureAfter` 注解指定在某个配置类之后加载。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  },
  {
    "module": "SpringBoot核心",
    "question": "Spring Boot 中，可通过 `spring.datasource` 前缀配置数据源的 URL、用户名、密码等信息。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  },
  {
    "module": "SpringBoot核心",
    "question": "Spring Boot Actuator 需引入 `spring-boot-starter-actuator` 依赖才能使用。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  },
  {
    "module": "SpringBoot核心",
    "question": "`@SpringBootConfiguration` 注解本质上是 `@Configuration` 注解的特殊形式，标识当前类为配置类。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  },
  {
    "module": "SpringBoot核心",
    "question": "整合 Spring Data JPA 时，引入 `spring-boot-starter-data-jpa` 依赖即可实现自动配置。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  },
  {
    "module": "SpringBoot核心",
    "question": "`@ConditionalOnProperty` 注解表示当配置文件中存在指定属性且值匹配时，自动配置才会生效。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  },
  {
    "module": "SpringBoot核心",
    "question": "Spring Boot 支持通过 `spring.jackson.date-format` 配置 JSON 格式日期的序列化方式。（（ ）",
    "type": "judge",
    "answer": "T",
    "options": [
      "正确",
      "错误"
    ]
  }
]